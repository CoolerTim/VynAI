<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>VynAI</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-MML-AM_CHTML"></script>
  <style>
    :root {
      --background-color: #0d1117;
      --chat-background: #161b22;
      --text-color: #e6edf3;
      --user-message-bg: #238636;
      --assistant-message-bg: #21262d;
      --primary-color: #238636;
      --secondary-color: #30363d;
      --border-radius: 12px;
      --shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      --code-bg: #1a1e24;
      --error-bg: #ff4444;
      --transition-speed: 0.3s;
      --accent-color: #58a6ff;
      --hover-color: #2ea043;
      --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      --card-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
      --input-bg: #0d1117;
      --input-border: #30363d;
      --input-focus-border: #58a6ff;
      --input-focus-shadow: 0 0 0 3px rgba(88, 166, 255, 0.3);
      --button-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      --button-hover-shadow: 0 6px 8px rgba(0, 0, 0, 0.2);
      --sidebar-width: 300px;
    }
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    body {
      font-family: var(--font-family);
      margin: 0;
      padding: 20px;
      background-color: var(--background-color);
      color: var(--text-color);
      display: flex;
      flex-direction: row;
      height: 100vh;
      gap: 20px;
      transition: background-color var(--transition-speed) ease;
      line-height: 1.6;
    }
    #sidebar, #memories-pane {
      width: 0;
      height: calc(100vh - 40px);
      position: fixed;
      z-index: 20;
      top: 20px;
      background-color: var(--secondary-color);
      overflow-x: hidden;
      overflow-y: auto;
      transition: width var(--transition-speed) ease, transform var(--transition-speed) ease;
      padding: 20px 0;
      border-radius: var(--border-radius);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }
    #sidebar {
      left: 20px;
    }
    #memories-pane {
      right: 20px;
    }
    #sidebar.open, #memories-pane.open {
      width: var(--sidebar-width);
      padding: 20px;
    }
    #sidebar .chat-card, #memories-pane .memory-card {
      background-color: var(--chat-background);
      padding: 15px;
      margin-bottom: 15px;
      border-radius: 8px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
      position: relative;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease, background-color 0.2s ease;
      border-left: 3px solid transparent;
    }
    #sidebar .chat-card:hover, #memories-pane .memory-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.25);
      border-left: 3px solid var(--primary-color);
    }
    #sidebar .chat-name, #memories-pane .memory-text {
      font-size: 16px;
      color: var(--text-color);
      margin: 0;
    }
    #sidebar .chat-card .menu-btn, #memories-pane .memory-card .menu-btn {
      position: absolute;
      top: 10px;
      right: 10px;
      background: none;
      border: none;
      color: var(--text-color);
      font-size: 20px;
      padding: 5px;
      cursor: pointer;
      transition: color 0.2s ease;
    }
    #sidebar .chat-card .menu-btn:hover, #memories-pane .memory-card .menu-btn:hover {
      color: var(--primary-color);
    }
    #sidebar .chat-card .dropdown, #memories-pane .memory-card .dropdown {
      display: none;
      position: absolute;
      top: 35px;
      right: 0;
      background-color: #2a2f38;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
      border-radius: 8px;
      z-index: 10;
      padding: 5px 0;
      min-width: 120px;
    }
    #sidebar .chat-card .dropdown button, #memories-pane .memory-card .dropdown button {
      display: block;
      width: 100%;
      padding: 10px 15px;
      background: none;
      border: none;
      color: #ff6666;
      text-align: left;
      cursor: pointer;
      font-size: 14px;
      transition: background-color 0.2s ease;
    }
    #sidebar .chat-card .dropdown button:hover, #memories-pane .memory-card .dropdown button:hover {
      background-color: var(--primary-color);
      color: #ffffff;
    }
    #main-container {
      flex-grow: 1;
      display: flex;
      flex-direction: column;
      max-width: 1200px;
      margin: 0 auto;
      transition: margin-left 0.3s ease, margin-right 0.3s ease;
      min-height: 0;
    }
    #main-container.shifted-left {
      margin-left: calc(var(--sidebar-width) + 40px);
    }
    #main-container.shifted-right {
      margin-right: calc(var(--sidebar-width) + 40px);
    }
    #controls {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 20px;
      margin-bottom: 20px;
      background-color: var(--secondary-color);
      padding: 15px 20px;
      border-radius: var(--border-radius);
      box-shadow: var(--shadow);
      position: sticky;
      top: 20px;
      z-index: 10;
    }
    #controls label {
      font-weight: 600;
      font-size: 14px;
      color: #8b949e;
      margin-right: 10px;
    }
    #chat-container {
      flex-grow: 1;
      overflow-y: auto;
      border: 1px solid #30363d;
      border-radius: var(--border-radius);
      padding: 20px;
      background-color: var(--chat-background);
      margin-bottom: 20px;
      box-shadow: var(--shadow);
      position: relative;
      scroll-behavior: smooth;
    }
    #chat-container::-webkit-scrollbar {
      width: 8px;
    }
    #chat-container::-webkit-scrollbar-track {
      background: var(--background-color);
      border-radius: 4px;
    }
    #chat-container::-webkit-scrollbar-thumb {
      background: var(--secondary-color);
      border-radius: 4px;
    }
    #chat-container::-webkit-scrollbar-thumb:hover {
      background: var(--primary-color);
    }
    .message {
      margin-bottom: 15px;
      max-width: 85%;
      font-size: 16px;
      position: relative;
      animation: fadeInUp 0.3s ease-out;
    }
    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    .message.user {
      margin-left: auto;
      text-align: right;
    }
    .message.assistant {
      margin-right: auto;
      text-align: left;
    }
    .message-content {
      display: inline-block;
      padding: 12px 16px;
      border-radius: var(--border-radius);
      word-wrap: break-word;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
    }
    .message.user .message-content {
      background-color: var(--user-message-bg);
      border-top-right-radius: 4px;
      position: relative;
    }
    .message.user .message-content::after {
      content: '';
      position: absolute;
      right: -10px;
      top: 0;
      width: 0;
      height: 0;
      border-top: 10px solid var(--user-message-bg);
      border-right: 10px solid transparent;
    }
    .message.assistant .message-content {
      background-color: var(--assistant-message-bg);
      border-top-left-radius: 4px;
      position: relative;
    }
    .message.assistant .message-content::after {
      content: '';
      position: absolute;
      left: -10px;
      top: 0;
      width: 0;
      height: 0;
      border-top: 10px solid var(--assistant-message-bg);
      border-left: 10px solid transparent;
    }
    .message span {
      display: block;
    }
    @keyframes fadeIn {
      to {
        opacity: 1;
      }
    }
    .message img {
      max-width: 100%;
      height: auto;
      border-radius: 6px;
      margin-top: 8px;
    }
    .message iframe {
      max-width: 100%;
      border-radius: 6px;
      margin-top: 8px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
      transition: transform 0.3s ease;
    }
    .message iframe.youtube-embed {
      aspect-ratio: 16 / 9;
      width: 560px;
      height: 315px;
    }
    .message iframe.spotify-embed {
      width: 100%;
      height: 152px;
      border-radius: 12px;
    }
    .message iframe:hover {
      transform: scale(1.02);
    }
    .message h1, .message h2, .message h3, .message h4, .message h5, .message h6 {
      margin: 8px 0 4px;
      color: #ffffff;
    }
    .message h1 { font-size: 24px; }
    .message h2 { font-size: 22px; }
    .message h3 { font-size: 20px; }
    .message h4 { font-size: 18px; }
    .message h5 { font-size: 16px; }
    .message h6 { font-size: 14px; }
    .message ul, .message ol {
      margin: 4px 0 4px 20px;
      padding-left: 10px;
    }
    .message li {
      margin-bottom: 4px;
      font-size: 15px;
    }
    .message a {
      color: var(--accent-color);
      text-decoration: none;
      transition: color 0.2s ease, text-decoration 0.2s ease;
    }
    .message a:hover {
      text-decoration: underline;
      color: #78b6ff;
    }
    .message sup a {
      font-size: 0.8em;
      margin-left: 2px;
      vertical-align: super;
    }
    .message hr {
      border: 0;
      border-top: 1px solid #30363d;
      margin: 8px 0;
    }
    .message pre {
      background-color: var(--code-bg);
      padding: 10px;
      border-radius: 6px;
      overflow-x: auto;
      font-size: 14px;
      margin: 8px 0;
    }
    .message code {
      background-color: var(--code-bg);
      padding: 2px 5px;
      border-radius: 4px;
      font-size: 14px;
    }
    .code-card {
      background-color: var(--code-bg);
      padding: 10px;
      border-radius: 8px;
      position: relative;
      margin: 8px 0;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
    }
    .code-card pre {
      margin: 0;
      white-space: pre-wrap;
      font-family: 'Courier New', Courier, monospace;
    }
    .code-card .copy-btn {
      position: absolute;
      top: 10px;
      right: 10px;
      padding: 5px 10px;
      background-color: var(--primary-color);
      color: var(--text-color);
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      transition: background-color 0.2s ease;
    }
    .code-card .copy-btn:hover {
      background-color: var(--hover-color);
    }
    .thinking, .searching {
      background-color: var(--assistant-message-bg);
      color: #8b949e;
      padding: 10px 15px;
      border-radius: var(--border-radius);
      max-width: 85%;
      margin-right: auto;
      box-shadow: var(--shadow);
      font-size: 15px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .thinking::before {
      content: "";
    }
    .searching::before {
      content: "🔍";
    }
    .thinking span, .searching span {
      animation: blink 1s infinite;
    }
    @keyframes blink {
      50% { opacity: 0.5; }
    }
    .error-message {
      background-color: var(--error-bg);
      color: #ffffff;
      padding: 12px 16px;
      border-radius: var(--border-radius);
      max-width: 85%;
      margin-right: auto;
      box-shadow: var(--shadow);
      font-size: 15px;
      text-align: center;
      animation: slideIn 0.3s ease-in-out;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .error-message::before {
      content: "⚠️";
      font-size: 18px;
    }
    @keyframes slideIn {
      from { transform: translateY(-20px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }
    #input-area {
      display: flex;
      gap: 10px;
      align-items: center;
      background-color: var(--secondary-color);
      padding: 15px 20px;
      border-radius: var(--border-radius);
      box-shadow: var(--shadow);
      position: sticky;
      bottom: 20px;
      z-index: 10;
      flex-wrap: nowrap;
    }
    #preview-area {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-shrink: 0;
      max-width: 300px;
      overflow-x: auto;
    }
    .file-card {
      background-color: #30363d;
      padding: 5px;
      border-radius: 6px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 3px;
      width: 60px;
      flex-shrink: 0;
    }
    .file-card span {
      max-width: 50px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      font-size: 10px;
      text-align: center;
    }
    .file-card img {
      width: 40px;
      height: 40px;
      object-fit: cover;
      border-radius: 4px;
    }
    #user-input {
      flex-grow: 1;
      padding: 12px 16px;
      background-color: var(--input-bg);
      color: var(--text-color);
      border: 1px solid var(--input-border);
      border-radius: var(--border-radius);
      font-size: 16px;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
      min-height: 50px;
      resize: none;
      line-height: 1.5;
      font-family: var(--font-family);
    }
    #user-input:focus {
      outline: none;
      border-color: var(--input-focus-border);
      box-shadow: var(--input-focus-shadow);
    }
    #send-button, #file-input-label, #new-chat-button, #sidebar-toggle, #memories-toggle {
      padding: 10px 20px;
      border: none;
      border-radius: var(--border-radius);
      background-color: var(--primary-color);
      color: var(--text-color);
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      transition: background-color 0.2s ease, transform 0.1s ease, box-shadow 0.2s ease;
      flex-shrink: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 5px;
      box-shadow: var(--button-shadow);
    }
    #send-button:hover, #file-input-label:hover, #new-chat-button:hover, #sidebar-toggle:hover, #memories-toggle:hover {
      background-color: var(--hover-color);
      transform: translateY(-1px);
      box-shadow: var(--button-hover-shadow);
    }
    #send-button:active, #file-input-label:active, #new-chat-button:active, #sidebar-toggle:active, #memories-toggle:active {
      transform: translateY(0);
      box-shadow: none;
    }
    #file-input {
      display: none;
    }
    .switch-container {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-shrink: 0;
    }
    .switch {
      position: relative;
      display: inline-block;
      width: 50px;
      height: 24px;
    }
    .switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #30363d;
      transition: .3s;
      border-radius: var(--border-radius);
    }
    .slider:before {
      position: absolute;
      content: "";
      height: 18px;
      width: 18px;
      left: 3px;
      bottom: 3px;
      background-color: #e6edf3;
      transition: .3s;
      border-radius: 50%;
    }
    input:checked + .slider {
      background-color: var(--primary-color);
    }
    input:checked + .slider:before {
      transform: translateX(26px);
    }
    .switch-label {
      font-size: 14px;
      color: #8b949e;
      font-weight: 500;
    }
    .model-select-container {
      position: relative;
      display: inline-block;
    }
    .model-select-button {
      padding: 10px 15px;
      background-color: var(--secondary-color);
      color: var(--text-color);
      border: 1px solid #30363d;
      border-radius: var(--border-radius);
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      transition: background-color 0.2s ease, box-shadow 0.2s ease;
    }
    .model-select-button:hover {
      background-color: #39414a;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
    }
    .model-select-dropdown {
      display: none;
      position: absolute;
      background-color: var(--chat-background);
      min-width: 160px;
      box-shadow: var(--shadow);
      z-index: 100;
      border-radius: var(--border-radius);
      border: 1px solid #30363d;
    }
    .model-select-dropdown button {
      color: var(--text-color);
      padding: 10px 15px;
      text-decoration: none;
      display: block;
      background-color: transparent;
      border: none;
      width: 100%;
      text-align: left;
      cursor: pointer;
      font-size: 14px;
      transition: background-color 0.2s ease;
    }
    .model-select-dropdown button:hover {
      background-color: var(--primary-color);
    }
    #sidebar-label, #memories-label {
      font-size: 18px;
      font-weight: 600;
      color: var(--text-color);
      margin: 0 0 15px 15px;
    }
    @keyframes memoryPulse {
      0% { background-color: var(--chat-background); }
      50% { background-color: #2a2f38; }
      100% { background-color: var(--chat-background); }
    }
    .memory-changed {
      animation: memoryPulse 1s ease-in-out;
    }
    @media (max-width: 1200px) {
      #main-container {
        max-width: 100%;
      }
      #main-container.shifted-left {
        margin-left: calc(var(--sidebar-width) + 40px);
      }
      #main-container.shifted-right {
        margin-right: calc(var(--sidebar-width) + 40px);
      }
    }
    @media (max-width: 768px) {
      body {
        padding: 15px;
        gap: 15px;
      }
      #sidebar.open {
        width: calc(var(--sidebar-width) - 20px);
      }
      #memories-pane.open {
        width: calc(var(--sidebar-width) - 20px);
      }
      #main-container.shifted-left {
        margin-left: calc(var(--sidebar-width) + 10px);
      }
      #main-container.shifted-right {
        margin-right: calc(var(--sidebar-width) + 10px);
      }
      #controls {
        flex-wrap: wrap;
        gap: 15px;
        padding: 12px 15px;
      }
      #chat-container {
        max-height: calc(100vh - 240px);
      }
      #input-area {
        gap: 10px;
        padding: 12px 15px;
      }
      .message iframe {
        width: 100%;
        height: auto;
      }
    }
    @media (max-width: 480px) {
      body {
        padding: 0;
        flex-direction: column;
        gap: 0;
        height: 100vh;
        overflow: hidden;
      }
      
      /* Improved sidebar and memories panel styling */
      #sidebar, #memories-pane {
        display: none;
        position: fixed;
        top: 0;
        width: 85%;
        height: 100vh;
        z-index: 30;
        transition: transform 0.3s ease;
        padding: 15px;
        border-radius: 0;
        overflow-y: auto;
        box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
      }
      
      #sidebar {
        left: 0;
        transform: translateX(-100%);
      }
      
      #memories-pane {
        right: 0;
        transform: translateX(100%);
      }
      
      #sidebar.open, #memories-pane.open {
        display: block;
        transform: translateX(0);
        width: 85%;
      }
      
      /* Improved close button styling */
      .close-panel {
        position: absolute;
        top: 10px;
        right: 10px;
        width: 36px;
        height: 36px;
        font-size: 24px;
        background-color: var(--accent-color);
        color: white;
        border: none;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 35;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
      }
      
      /* Enhanced overlay */
      .overlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        z-index: 25;
        backdrop-filter: blur(3px);
      }
      
      .overlay.active {
        display: block;
      }
      
      /* Main container improvements */
      #main-container {
        margin: 0;
        width: 100%;
        height: 100vh;
        max-width: none;
        padding: 0;
        display: flex;
        flex-direction: column;
      }
      
      /* Controls bar improvements */
      #controls {
        flex-direction: row;
        justify-content: space-between;
        align-items: center;
        padding: 10px 15px;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 60px;
        z-index: 20;
        border-radius: 0;
        background-color: var(--secondary-color);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
      }
      
      #controls label {
        display: none;
      }
      
      /* Fix for duplicate icons */
      #sidebar-toggle, #memories-toggle {
        font-size: 20px;
        width: 40px;
        height: 40px;
        padding: 0;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      
      #memories-toggle {
        font-size: 22px;
      }
      
      /* Chat container improvements */
      #chat-container {
        flex: 1;
        margin-top: 60px;
        margin-bottom: 130px;
        padding: 15px;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
        scroll-behavior: smooth;
        max-height: none;
      }
      
      /* Input area improvements */
      #input-area {
        position: fixed;
        bottom: 0;
        left: 0;
        width: 100%;
        padding: 10px;
        background-color: var(--secondary-color);
        border-radius: 0;
        box-shadow: 0 -2px 8px rgba(0, 0, 0, 0.2);
        z-index: 20;
        display: grid;
        grid-template-columns: auto 1fr auto;
        grid-template-rows: auto auto;
        grid-template-areas:
          "upload input send"
          "preview preview toggle";
        gap: 8px;
        align-items: center;
      }
      
      #file-input-label {
        grid-area: upload;
        width: 40px;
        height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 20px;
        background-color: var(--primary-color);
        color: var(--text-color);
        border-radius: 50%;
        margin: 0;
      }
      
      #user-input {
        grid-area: input;
        height: 40px;
        padding: 8px 12px;
        border-radius: 20px;
      }
      
      #send-button {
        grid-area: send;
        width: 40px;
        height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 18px;
        padding: 0;
        border-radius: 50%;
      }
      
      #preview-area {
        grid-area: preview;
        width: 100%;
        max-height: 100px;
        overflow-y: auto;
        padding: 5px 0;
      }
      
      .switch-container {
        grid-area: toggle;
        display: flex;
        align-items: center;
        justify-content: flex-end;
        margin-right: 5px;
      }
      
      /* Message styling improvements */
      .message {
        padding: 12px;
        margin-bottom: 15px;
        border-radius: 12px;
        max-width: 90%;
      }
      
      .message iframe, .message img {
        max-width: 100%;
        border-radius: 8px;
      }
      
      /* Improved YouTube and Spotify embeds */
      .youtube-embed, .spotify-embed {
        width: 100% !important;
        margin: 10px 0;
        border-radius: 12px;
        overflow: hidden;
      }
    }
    #sidebar-toggle, #memories-toggle {
      position: relative;
      overflow: hidden;
    }
    #sidebar-toggle::after, #memories-toggle::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 100%;
      height: 100%;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 50%;
      transform: translate(-50%, -50%) scale(0);
      opacity: 0;
      transition: transform 0.5s, opacity 0.3s;
    }
    #sidebar-toggle:active::after, #memories-toggle:active::after {
      transform: translate(-50%, -50%) scale(2);
      opacity: 1;
      transition: 0s;
    }
    /* Additional styles for improved mobile UI */
    .empty-message {
      padding: 20px;
      text-align: center;
      color: var(--muted-color);
      font-style: italic;
    }
    
    /* Scroll indicators */
    #chat-container.at-top::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 5px;
      background: linear-gradient(to bottom, rgba(0,0,0,0.2), transparent);
      pointer-events: none;
    }
    
    #chat-container.at-bottom::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 5px;
      background: linear-gradient(to top, rgba(0,0,0,0.2), transparent);
      pointer-events: none;
    }
    
    /* Improved mobile chat cards */
    .chat-card, .memory-card {
      position: relative;
      padding: 12px;
      margin-bottom: 10px;
      background-color: var(--primary-color);
      border-radius: 8px;
      cursor: pointer;
      transition: background-color 0.2s;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    
    .chat-card:hover, .memory-card:hover {
      background-color: var(--hover-color);
    }
    
    .chat-name, .memory-text {
      margin: 0;
      padding-right: 30px;
      word-break: break-word;
    }
    
    .menu-btn {
      position: absolute;
      top: 8px;
      right: 8px;
      background: none;
      border: none;
      font-size: 18px;
      cursor: pointer;
      color: var(--text-color);
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
    }
    
    .menu-btn:hover {
      background-color: var(--hover-color);
    }
    
    .dropdown {
      position: absolute;
      top: 40px;
      right: 5px;
      background-color: var(--secondary-color);
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      display: none;
      z-index: 10;
      overflow: hidden;
    }
    
    .dropdown button {
      padding: 10px 15px;
      width: 100%;
      text-align: left;
      background: none;
      border: none;
      color: var(--text-color);
      cursor: pointer;
      white-space: nowrap;
    }
    
    .dropdown button:hover {
      background-color: var(--hover-color);
    }
    
    /* Mobile keyboard adjustments */
    body.keyboard-open #chat-container {
      margin-bottom: 180px;
    }
  </style>
</head>
<body>
  <div id="sidebar">
    <h2 id="sidebar-label">History</h2>
    <button class="close-panel" aria-label="Close history panel">&times;</button>
    <div class="sidebar-content"></div>
  </div>
  
  <div id="memories-pane">
    <h2 id="memories-label">Memories</h2>
    <button class="close-panel" aria-label="Close memories panel">&times;</button>
    <div class="memories-content"></div>
  </div>
  
  <div class="overlay"></div>
  
  <div id="main-container">
    <div id="controls">
      <button id="sidebar-toggle" aria-label="Toggle history">☰</button>
      <div class="model-select-container">
        <label for="model-select-button">Model:</label>
        <button class="model-select-button" id="model-select-button">Pro (Advanced)</button>
        <div class="model-select-dropdown" id="model-select-dropdown">
          <button data-value="openai-large">Pro (Advanced)</button>
          <button data-value="openai">Fast (Standard)</button>
        </div>
      </div>
      <button id="new-chat-button">New Chat</button>
      <button id="memories-toggle" aria-label="Toggle memories">🧠</button>
    </div>
    
    <div id="chat-container"></div>
    
    <div id="input-area">
      <label for="file-input" id="file-input-label" aria-label="Upload files">📎</label>
      <input type="file" id="file-input" accept="image/*, .txt, .pdf, .doc, .docx, .ppt, .pptx" multiple>
      <textarea id="user-input" placeholder="Type your message..."></textarea>
      <button id="send-button" aria-label="Send message">➤</button>
      <div id="preview-area"></div>
      <div class="switch-container">
        <label class="switch-label">Web Search</label>
        <label class="switch">
          <input type="checkbox" id="web-search-toggle">
          <span class="slider round"></span>
        </label>
      </div>
    </div>
  </div>

  <script>
    let conversation = [];
    let memories = JSON.parse(localStorage.getItem('memories')) || [];
    let sources = [];
    let chatHistory = JSON.parse(localStorage.getItem('chatHistory')) || [];
    let currentChatIndex = -1;
    const MAX_CHARS = 512000;
    let selectedModel = 'openai-large';
    let userLanguage = 'Unknown';
    let userCity = 'Unknown';
    let locationFetched = false;

    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.worker.min.js';

    function escapeHtml(text) {
      return text
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
    }

    function addMessageToChat(role, content, isNew = true) {
      const chatContainer = document.getElementById('chat-container');
      const messageDiv = document.createElement('div');
      messageDiv.classList.add('message', role);
      
      const contentDiv = document.createElement('div');
      contentDiv.classList.add('message-content');

      if (typeof content === 'string') {
        const codeRegex = /```([\s\S]*?)```/g;
        let lastIndex = 0;
        let match;

        while ((match = codeRegex.exec(content)) !== null) {
          const preText = content.slice(lastIndex, match.index);
          if (preText) {
            const preLines = (role === 'user' ? escapeHtml(preText) : parseLatexAndMarkdown(preText)).split('<br>');
            preLines.forEach((line, index) => {
              const lineSpan = document.createElement('span');
              lineSpan.innerHTML = line;
              if (isNew) {
                lineSpan.style.opacity = '0';
                lineSpan.style.animation = `fadeIn 0.3s forwards`;
                lineSpan.style.animationDelay = `${index * 0.05}s`;
              } else {
                lineSpan.style.opacity = '1';
              }
              contentDiv.appendChild(lineSpan);
              if (index < preLines.length - 1) contentDiv.appendChild(document.createElement('br'));
            });
          }

          const codeCard = document.createElement('div');
          codeCard.classList.add('code-card');
          const codeContent = match[1].trim();
          const pre = document.createElement('pre');
          pre.textContent = codeContent;
          codeCard.appendChild(pre);

          const copyBtn = document.createElement('button');
          copyBtn.classList.add('copy-btn');
          copyBtn.textContent = 'Copy';
          copyBtn.addEventListener('click', () => {
            navigator.clipboard.writeText(codeContent).then(() => {
              copyBtn.textContent = 'Copied!';
              setTimeout(() => copyBtn.textContent = 'Copy', 2000);
            });
          });
          codeCard.appendChild(copyBtn);

          contentDiv.appendChild(codeCard);
          lastIndex = codeRegex.lastIndex;
        }

        const remainingText = content.slice(lastIndex);
        if (remainingText) {
          const lines = (role === 'user' ? escapeHtml(remainingText) : parseLatexAndMarkdown(remainingText)).split('<br>');
          lines.forEach((line, index) => {
            const lineSpan = document.createElement('span');
            lineSpan.innerHTML = line;
            if (isNew) {
              lineSpan.style.opacity = '0';
              lineSpan.style.animation = `fadeIn 0.3s forwards`;
              lineSpan.style.animationDelay = `${index * 0.05}s`;
            } else {
              lineSpan.style.opacity = '1';
            }
            contentDiv.appendChild(lineSpan);
            if (index < lines.length - 1) contentDiv.appendChild(document.createElement('br'));
          });
        }
      } else {
        content.forEach(item => {
          if (item.type === 'text') {
            const textSpan = document.createElement('span');
            textSpan.innerHTML = parseLatexAndMarkdown(item.text);
            if (isNew) {
              textSpan.style.opacity = '0';
              textSpan.style.animation = `fadeIn 0.3s forwards`;
            } else {
              textSpan.style.opacity = '1';
            }
            contentDiv.appendChild(textSpan);
          } else if (item.type === 'image_url') {
            const img = document.createElement('img');
            img.src = item.image_url.url;
            img.alt = "Uploaded image";
            img.loading = "lazy";
            contentDiv.appendChild(img);
          }
        });
      }
      
      messageDiv.appendChild(contentDiv);
      chatContainer.appendChild(messageDiv);
      
      // Scroll to the new message with a slight delay to ensure rendering
      setTimeout(() => {
        // On mobile, use a smoother scroll
        if (window.innerWidth <= 480) {
          messageDiv.scrollIntoView({ behavior: 'smooth', block: 'end' });
        } else {
          messageDiv.scrollIntoView({ behavior: 'smooth' });
        }
        
        // Process math expressions
        MathJax.Hub.Queue(["Typeset", MathJax.Hub, messageDiv]);
      }, 50);
      
      return messageDiv;
    }

    function addErrorMessage(message) {
      const errorDiv = document.createElement('div');
      errorDiv.classList.add('error-message');
      errorDiv.innerHTML = `<span>${message}</span>`;
      document.getElementById('chat-container').appendChild(errorDiv);
      errorDiv.scrollIntoView({ behavior: 'smooth' });
      setTimeout(() => errorDiv.remove(), 5000);
    }

    function addThinkingMessage() {
      const messageDiv = document.createElement('div');
      messageDiv.classList.add('thinking');
      messageDiv.innerHTML = '<span>Thinking...</span>';
      document.getElementById('chat-container').appendChild(messageDiv);
      messageDiv.scrollIntoView({ behavior: 'smooth' });
      return messageDiv;
    }

    function addSearchLoadingMessage() {
      const messageDiv = document.createElement('div');
      messageDiv.classList.add('searching');
      messageDiv.innerHTML = '<span>Searching the web...</span>';
      document.getElementById('chat-container').appendChild(messageDiv);
      messageDiv.scrollIntoView({ behavior: 'smooth' });
      return messageDiv;
    }

    function removeLoadingMessage(loadingMessage) {
      if (loadingMessage) loadingMessage.remove();
    }

    function parseLatexAndMarkdown(text) {
      const sourceRegex = /\[(\d+)\]: \[([^\[\]]*?)\]\((https?:\/\/[^\s)]+?)\)/g;
      sources = [];
      let match;
      while ((match = sourceRegex.exec(text)) !== null) {
        sources[parseInt(match[1])] = { text: match[2], url: match[3] };
      }
      let latexText = text
        .replace(/\\\((.*?)\\\)/g, '$$$1$$')
        .replace(/\$(.*?)\$/g, (match, p1) => `$$${p1.replace(/\\(?![()])/g, '\\\\')}$$`);
      return latexText
        .replace(/^###### (.*)$/gim, '<h6>$1</h6>')
        .replace(/^##### (.*)$/gim, '<h5>$1</h5>')
        .replace(/^#### (.*)$/gim, '<h4>$1</h4>')
        .replace(/^### (.*)$/gim, '<h3>$1</h3>')
        .replace(/^## (.*)$/gim, '<h2>$1</h2>')
        .replace(/^# (.*)$/gim, '<h1>$1</h1>')
        .replace(/^---$/gim, '<hr>')
        .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
        .replace(/\*(.*?)\*/g, '<em>$1</em>')
        .replace(/~~(.*?)~~/g, '<del>$1</del>')
        .replace(/\[([^\[\]]*?)\]\((https?:\/\/[^\s)]+?)\)/g, '<a href="$2" target="_blank">$1</a>')
        .replace(/\[(\d+)\]/g, (match, number) => {
          const source = sources[parseInt(number)];
          return source && source.url.startsWith('http') ? `<sup><a href="${source.url}" target="_blank">${number}</a></sup>` : '';
        })
        .replace(/^- (.*)$/gim, '<li>$1</li>')
        .replace(/<\/li>\n<li>/g, '</li><li>')
        .replace(/(<li>.*<\/li>)/g, '<ul>$1</ul>')
        .replace(/\n{2,}/g, '<br>')
        .replace(/\n/g, '<br>');
    }

    function getRandomSeed() {
      return Math.floor(Math.random() * 1000000);
    }

    async function detectLanguage(text) {
      if (/[äöüß]/.test(text)) return 'de';
      if (/[áéíóúñ]/.test(text)) return 'es';
      if (/[àâçéèêîôûù]/.test(text)) return 'fr';
      return 'en';
    }

    async function getUserCity() {
      return new Promise((resolve) => {
        if (navigator.geolocation) {
          navigator.geolocation.getCurrentPosition(
            async (position) => {
              const { latitude, longitude } = position.coords;
              try {
                const response = await fetch(`https://nominatim.openstreetmap.org/reverse?lat=${latitude}&lon=${longitude}&format=json`);
                const data = await response.json();
                resolve(data.address.city || data.address.town || 'Unknown');
              } catch (error) {
                console.error('Geolocation fetch error:', error);
                resolve('Unknown');
              }
            },
            () => resolve('Unknown'),
            { timeout: 5000, maximumAge: 60000 }
          );
        } else {
          resolve('Unknown');
        }
      });
    }

    async function updateUserInfo() {
      if (!locationFetched) {
        const firstMessage = document.getElementById('user-input').value.trim() || conversation[0]?.content || ' ';
        userLanguage = await detectLanguage(firstMessage);
        userCity = await getUserCity();
        locationFetched = true;
      }
    }

    async function updateChatAndMemories() {
      const conversationText = conversation.slice(-5).map(m => typeof m.content === 'string' ? m.content : m.content[0]?.text || '').join('\n');
      const existingMemories = memories.map(m => m.content).join('\n');
      const language = await detectLanguage(conversationText);

      const requestBody = {
        messages: [
          {
            "role": "system",
            "content": `Perform two tasks based on the conversation:
1. Generate a concise chat name (1-3 words) summarizing the conversation, in ${language}.
2. Update the memories list with persistent, relevant facts about the user. Format memories as natural, complete sentences rather than label-style entries. For example, use "User lives in Berlin" instead of "Lives in: Berlin" and "User follows a vegan diet" instead of "Likes: Vegan".

Include information such as:
- Personal information (e.g., "User's name is Alice", "User is 32 years old")
- Future plans (e.g., "User plans to visit Paris on March 15, 2025")
- Personality traits (e.g., "User has a cheerful personality")
- Preferences for AI responses (e.g., "User prefers detailed technical explanations")
- Interests and hobbies (e.g., "User enjoys hiking in the mountains")
- Dietary preferences (e.g., "User follows a vegan diet")

EXCLUDE temporary states (e.g., "User is feeling good today") and chat-specific queries (e.g., "User wants to know what X is"). Add or edit based on explicit statements or light inference, but do not over-interpret. Only remove entries if they are explicitly contradicted or outdated; never delete all memories unless "forget everything" is in the conversation. If the input is large or unclear, preserve existing memories unchanged.

Return a JSON object with:
- "chatName": string (the chat name)
- "memories": array of strings (one memory per entry)

Conversation:
${conversationText}

Current Memories:
${existingMemories}`
          }
        ],
        model: 'openai',
        seed: getRandomSeed(),
        private: true,
        jsonMode: true
      };

      console.log('Chat & Memory AI Request Body:', JSON.stringify(requestBody));

      try {
        const response = await fetch('https://text.pollinations.ai/', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(requestBody)
        });

        if (!response.ok) {
          throw new Error(`Server responded with status ${response.status}`);
        }

        const result = await response.json();
        console.log('Chat & Memory AI Response:', result);

        if (!result.chatName || !Array.isArray(result.memories)) {
          throw new Error('Invalid response format');
        }

        const chatName = result.chatName.trim() || 'New Chat';
        const oldMemories = memories.map(m => m.content);
        const newMemories = result.memories;
        const memoriesChanged = oldMemories.length !== newMemories.length || oldMemories.some((m, i) => m !== newMemories[i]);

        memories = newMemories.map(content => ({ content, timestamp: new Date().toISOString() }));
        localStorage.setItem('memories', JSON.stringify(memories));
        
        if (memoriesChanged) {
          const memoriesPane = document.getElementById('memories-pane');
          memoriesPane.querySelectorAll('.memory-card').forEach(card => {
            card.classList.add('memory-changed');
            card.addEventListener('animationend', () => card.classList.remove('memory-changed'), { once: true });
          });
        }
        
        updateMemoriesPane();
        return chatName;
      } catch (error) {
        console.error('Chat & Memory update failed:', error);
        return 'New Chat';
      }
    }

    async function tryWebSearch(prompt, maxAttempts = 3, isYouTubeSearch = false, isSpotifySearch = false) {
      let attemptsMade = 0;
      let delay = 1000; // 1 second delay between attempts
      
      while (attemptsMade < maxAttempts) {
        attemptsMade++;
        console.log(`Attempt ${attemptsMade} of ${maxAttempts}`);
        
        try {
          let systemPrompt;
          let language = detectLanguage(prompt);
          const currentDate = new Date().toLocaleString();
          
          if (isYouTubeSearch) {
            systemPrompt = `Return a relevant YouTube video for the query: "${prompt}". 
            
IMPORTANT REQUIREMENTS:
- Only return valid, existing YouTube videos that can be embedded
- Prioritize videos from official channels, famous creators, or with high view counts
- Verify the video exists and is not age-restricted or private
- The video ID must be the exact ID from the YouTube URL (typically 11 characters)

Return the result in this exact JSON format:
{"youtube_url": "https://www.youtube.com/watch?v=VIDEO_ID", "title": "Video Title"}

If no suitable video can be found, return:
{"youtube_url": null}`;
          } else if (isSpotifySearch) {
            // Get web search context first if this is a direct Spotify search
            let webContext = "";
            if (!prompt.toLowerCase().includes("spotify")) {
              try {
                const webSearchResult = await tryWebSearch(prompt, 1, false, false);
                if (webSearchResult && webSearchResult.results && webSearchResult.results.length > 0) {
                  // Extract relevant context from web search
                  webContext = "Based on these facts: ";
                  for (let i = 0; i < Math.min(webSearchResult.results.length, 5); i++) {
                    webContext += webSearchResult.results[i].Fact + "; ";
                  }
                }
              } catch (error) {
                console.log("Error getting web context for Spotify search:", error);
                // Continue without web context if there's an error
              }
            }
            
            systemPrompt = `${webContext}Return a relevant Spotify track, album, or playlist for the query: "${prompt}".

IMPORTANT REQUIREMENTS:
- Only return valid, existing Spotify content
- Prioritize popular or well-known content with many plays or followers
- Verify the content exists on Spotify before returning it
- The Spotify ID must be the exact ID from the Spotify URL (typically 22 characters)

Return the result in this exact JSON format:
{"spotify_url": "https://open.spotify.com/track/SPOTIFY_ID", "title": "Content Title", "type": "track|album|playlist"}

If no suitable content can be found, return:
{"spotify_url": null}`;
          } else {
            systemPrompt = `If you have no internet access, return exactly "XNoInternetX". Otherwise, conduct a comprehensive and detailed web research for the given prompt in the language detected as "${language}". Provide current information (as of ${currentDate} or later, if available), including precise facts, background details, and relevant insights. 

CRITICAL REQUIREMENTS FOR FACT VERIFICATION:
1. ONLY include information that you can VERIFY from reliable sources
2. NEVER hallucinate facts or make up information not found in your sources
3. ALWAYS double-check information across multiple sources when possible
4. If sources contradict each other, acknowledge the discrepancy and present both viewpoints
5. If you cannot find reliable information on a topic, state clearly that "No reliable information was found on this specific point"
6. For controversial topics, present multiple perspectives from different reliable sources

For each fact, include:
1. The exact information with specific numbers, dates, and details
2. Context and background information when relevant
3. Multiple perspectives or viewpoints when applicable
4. Comparisons with similar topics when helpful
5. Recent developments or updates

Ensure each fact is accompanied by a source URL from trustworthy, up-to-date references. Return your answer in an array with two keys each: Fact and Source (the source must be the exact URL where the fact came from!). 

RELIABLE SOURCES include:
- Academic journals and research papers
- Government websites (.gov domains)
- Educational institutions (.edu domains)
- Established news organizations with fact-checking processes
- Official organizational websites for the topic in question
- Peer-reviewed publications
- Primary sources (original documents, official statements, etc.)

AVOID using sources that:
- Have a clear bias or agenda
- Are known for spreading misinformation
- Lack editorial oversight
- Are anonymous or lack clear authorship
- Contradict well-established scientific consensus without compelling evidence

Additionally, determine if this query would benefit from a YouTube video or Spotify content. Set these flags at the end of your response:
- YouTube: true/false (set to true if a video would enhance the answer, such as for tutorials, music videos, documentaries, etc.)
- Spotify: true/false (set to true if music content would enhance the answer, such as for songs, albums, artists, playlists, etc.)

Examples of when to set YouTube: true:
- Queries about how to do something visual (tutorials, demonstrations)
- Requests about music videos, movie trailers, or visual content
- Topics that would benefit from visual explanation
- Historical events with available footage
- Product reviews or demonstrations

Examples of when to set Spotify: true:
- Direct queries about songs, albums, artists, or playlists
- Music recommendations or discussions
- Queries about music genres, trends, or history
- Requests for background music or mood playlists
- Discussions about podcasts available on Spotify

Make the search as detailed as possible with at least 10-15 distinct facts when available. Prioritize authoritative sources like academic journals, government websites, and reputable news outlets. Never write anything without checking the sources for trustworthiness!`;
          }
          
          const searchResponse = await fetch('https://text.pollinations.ai/', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              messages: [
                {"role": "system", "content": systemPrompt},
                {"role": "user", "content": prompt}
              ],
              model: 'searchgpt',
              seed: getRandomSeed(),
              jsonMode: true,
              private: true
            })
          });

          if (!searchResponse.ok) {
            console.log(`Attempt ${attemptsMade}: API call failed with status ${searchResponse.status}`);
            if (attemptsMade < maxAttempts) {
              await new Promise(resolve => setTimeout(resolve, delay));
              delay += 1000; // Increase delay for subsequent attempts
              continue;
            } else {
              return { error: true, message: `Search failed after ${attemptsMade} attempts: API error ${searchResponse.status}`, attemptsMade: attemptsMade };
            }
          }

          const result = await searchResponse.json();
          console.log(`Search result (Attempt ${attemptsMade}):`, result);
          
          // Check for "XNoInternetX" in the response
          if ((typeof result === 'string' && result.includes('XNoInternetX')) || 
              (typeof result === 'object' && JSON.stringify(result).includes('XNoInternetX')) ||
              (typeof result === 'string' && result.includes('"Fact":"XNoInternetX"'))) {
            console.log(`Attempt ${attemptsMade}: No internet access detected`);
            if (attemptsMade < maxAttempts) {
              await new Promise(resolve => setTimeout(resolve, delay));
              delay += 1000; // Increase delay for subsequent attempts
              continue;
            } else {
              return { error: true, message: `Search failed after ${attemptsMade} attempts: No internet access`, attemptsMade: attemptsMade };
            }
          }

          // Check for error in the result
          if (result && result.error) {
            console.log(`Attempt ${attemptsMade}: Search returned error: ${result.message || 'undefined'}`);
            if (attemptsMade < maxAttempts) {
              await new Promise(resolve => setTimeout(resolve, delay));
              delay += 1000; // Increase delay for subsequent attempts
              continue;
            } else {
              return { error: true, message: `Search failed after ${attemptsMade} attempts: ${result.message || 'undefined'}`, attemptsMade: attemptsMade };
            }
          }

          // For YouTube searches
          if (isYouTubeSearch) {
            if (result && result.youtube_url) {
              const videoIdMatch = result.youtube_url.match(/v=([^&]+)/);
              if (videoIdMatch && videoIdMatch[1]) {
                const videoId = videoIdMatch[1];
                
                // Validate the YouTube URL by attempting to fetch it
                try {
                  const response = await fetch(`https://www.youtube.com/oembed?url=${result.youtube_url}`, { method: 'HEAD' });
                  if (response.ok) {
                    console.log(`YouTube Search Result (Attempt ${attemptsMade}):`, result);
                    return { error: false, result: result, attemptsMade: attemptsMade };
                  } else {
                    console.error(`YouTube video exists but cannot be embedded: ${result.youtube_url}`);
                    return { error: true, message: `YouTube video exists but cannot be embedded: ${result.youtube_url}`, attemptsMade: attemptsMade };
                  }
                } catch (error) {
                  console.error(`Failed to validate YouTube URL: ${error.message}`);
                  return { error: true, message: `Failed to validate YouTube URL: ${error.message}`, attemptsMade: attemptsMade };
                }
              } else {
                console.log('Invalid YouTube URL format received');
                return { error: true, message: `Invalid YouTube URL format received: ${result.youtube_url}`, attemptsMade: attemptsMade };
              }
            } else {
              console.log('No YouTube URL found in result');
              return { error: true, message: 'No YouTube URL found in result', attemptsMade: attemptsMade };
            }
          } else if (isSpotifySearch) {
            if (result && result.spotify_url) {
              // Extract content type and ID from Spotify URL
              const spotifyUrlPattern = /spotify\.com\/(track|album|playlist|artist)\/([a-zA-Z0-9]+)/;
              const spotifyMatch = result.spotify_url.match(spotifyUrlPattern);
              
              if (spotifyMatch && spotifyMatch[1] && spotifyMatch[2]) {
                const contentType = spotifyMatch[1];
                const contentId = spotifyMatch[2];
                
                // Validate the Spotify URL by attempting to fetch it
                try {
                  const response = await fetch(`https://open.spotify.com/${contentType}/${contentId}`, { 
                    method: 'HEAD',
                    mode: 'no-cors' // To avoid CORS issues
                  });
                  
                  console.log(`Spotify Search Result (Attempt ${attemptsMade}):`, result);
                  return { 
                    error: false, 
                    result: {
                      spotify_url: result.spotify_url,
                      title: result.title || "Spotify Content",
                      type: contentType
                    }, 
                    attemptsMade: attemptsMade 
                  };
                } catch (error) {
                  console.error(`Failed to validate Spotify URL: ${error.message}`);
                  if (attemptsMade < maxAttempts) {
                    await new Promise(resolve => setTimeout(resolve, delay));
                    delay += 1000;
                    continue;
                  }
                  return { error: true, message: `Failed to validate Spotify URL: ${error.message}`, attemptsMade: attemptsMade };
                }
              } else {
                console.log('Invalid Spotify URL format received');
                if (attemptsMade < maxAttempts) {
                  await new Promise(resolve => setTimeout(resolve, delay));
                  delay += 1000;
                  continue;
                }
                return { error: true, message: `Invalid Spotify URL format received: ${result.spotify_url}`, attemptsMade: attemptsMade };
              }
            } else {
              // Legacy code for handling spotify_selection
              // Map of pre-verified working Spotify tracks
              const spotifyTracks = {
                "1": { id: "7qiZfU4dY1lWllzX7mPBI3", title: "Shape of You - Ed Sheeran", type: "track" },
                "2": { id: "4u7EnebtmKWzUH433cf5Qv", title: "Bohemian Rhapsody - Queen", type: "track" },
                "3": { id: "5ChkMS8OtdzJeqyybCc9R5", title: "Billie Jean - Michael Jackson", type: "track" },
                "4": { id: "5CQ30WqJwcep0pYcV4AMNc", title: "Stairway to Heaven - Led Zeppelin", type: "track" },
                "5": { id: "5ghIJDpPoe3CfHMGu71E6T", title: "Smells Like Teen Spirit - Nirvana", type: "track" },
                "6": { id: "40riOy7x9W7GXjyGp4pjAv", title: "Hotel California - Eagles", type: "track" },
                "7": { id: "7o2CTH4ctstm8TNelqjb51", title: "Sweet Child O' Mine - Guns N' Roses", type: "track" },
                "8": { id: "7pKfPomDEeI4TPT6EOYjn9", title: "Imagine - John Lennon", type: "track" },
                "9": { id: "2LlQb7oMpft1qczHlcbzYi", title: "Thriller - Michael Jackson", type: "track" },
                "10": { id: "5qqabIl2vWzo9ApSC317sa", title: "Wonderwall - Oasis", type: "track" },
                "11": { id: "0aym2LBJBk9DAYuHHutrIl", title: "Hey Jude - The Beatles", type: "track" },
                "12": { id: "3AhXZa8sUQht0UEdBJgpGc", title: "Like a Rolling Stone - Bob Dylan", type: "track" },
                "13": { id: "0wJoRiX5K5BxlqZTolB2LD", title: "Purple Haze - Jimi Hendrix", type: "track" },
                "14": { id: "7y69MRxUAjvgCvJ4LdQQUq", title: "Johnny B. Goode - Chuck Berry", type: "track" },
                "15": { id: "5ZBeML7Lf3FMEVviTyvi8l", title: "I Want to Hold Your Hand - The Beatles", type: "track" },
                "16": { id: "7s25THrKz86DM225dOYwnr", title: "Respect - Aretha Franklin", type: "track" },
                "17": { id: "6hTcuIQa0sxrrByu9wTD7s", title: "Born to Run - Bruce Springsteen", type: "track" },
                "18": { id: "1qiQduG0FgxdAn3xHmH1Sq", title: "Superstition - Stevie Wonder", type: "track" },
                "19": { id: "1JSTJqkT5qHq8MDJnJbRE1", title: "Every Breath You Take - The Police", type: "track" },
                "20": { id: "3pRaLNL3b8x5uBOcsgvdqM", title: "Hallelujah - Leonard Cohen", type: "track" },
                "21": { id: "3BQHpFgAp4l80e1XslIjNI", title: "Yesterday - The Beatles", type: "track" },
                "22": { id: "3Um9toULmYFGCpvaIPFw5v", title: "What's Going On - Marvin Gaye", type: "track" },
                "23": { id: "2Ld0LxkXJFLTpW0jhvtUfg", title: "Waterloo Sunset - The Kinks", type: "track" },
                "24": { id: "6iGYe8M6ZmD8MwJJkSnAd6", title: "God Only Knows - The Beach Boys", type: "track" },
                "25": { id: "5FVd6KXrgO9B3JPmC8OPst", title: "London Calling - The Clash", type: "track" },
                "26": { id: "7tr2za8SQg2CI8EDgrdtNl", title: "Good Vibrations - The Beach Boys", type: "track" },
                "27": { id: "0GjEhVFGZW8afUYGChu3Rr", title: "Dancing Queen - ABBA", type: "track" },
                "28": { id: "5WoaF1B5XIEnWfmb5NZikf", title: "I Want You Back - Jackson 5", type: "track" },
                "29": { id: "6H3kDe7CGoWYBabAeVWGiD", title: "Gimme Shelter - The Rolling Stones", type: "track" },
                "30": { id: "3BEmmHuv5jm0tbzWlFZxUH", title: "One - U2", type: "track" }
              };
              
              // Get the selected track
              const selection = result.spotify_selection;
              if (spotifyTracks[selection]) {
                const track = spotifyTracks[selection];
                console.log(`Spotify Search Result (Attempt ${attemptsMade}): Selected track #${selection} - ${track.title}`);
                return { 
                  error: false, 
                  result: { 
                    spotify_url: `https://open.spotify.com/track/${track.id}`, 
                    title: track.title, 
                    type: "track" 
                  }, 
                  attemptsMade: attemptsMade 
                };
              } else {
                // Default to track #1 if selection is invalid
                const track = spotifyTracks["1"];
                console.log(`Invalid selection #${selection}, defaulting to track #1`);
                return { 
                  error: false, 
                  result: { 
                    spotify_url: `https://open.spotify.com/track/${track.id}`, 
                    title: track.title, 
                    type: "track" 
                  }, 
                  attemptsMade: attemptsMade,
                  isDefault: true
                };
              }
            }
          } else {
            // For regular web searches
            console.log(`Web Search Result (Attempt ${attemptsMade}):`, result);
            
            // Check if the result contains YouTube or Spotify flags
            const resultStr = result.toString();
            const needsYouTube = resultStr.includes('"YouTube": true') || resultStr.includes('"YouTube":true');
            const needsSpotify = resultStr.includes('"Spotify": true') || resultStr.includes('"Spotify":true');
            
            // Also check for music-related keywords in the query to improve Spotify detection
            const musicKeywords = ['song', 'music', 'track', 'artist', 'band', 'album', 'playlist', 'spotify', 'listen', 'play'];
            const hasMusicKeywords = musicKeywords.some(keyword => prompt.toLowerCase().includes(keyword));
            
            return { 
              error: false, 
              result: result, 
              attemptsMade: attemptsMade,
              needsYouTube: needsYouTube,
              needsSpotify: needsSpotify || hasMusicKeywords
            };
          }
        } catch (error) {
          console.error(`Search attempt ${attemptsMade} failed:`, error);
          if (attemptsMade < maxAttempts) {
            await new Promise(resolve => setTimeout(resolve, delay));
            delay += 1000; // Increase delay for subsequent attempts
            continue;
          } else {
            return { error: true, message: `Search failed after ${attemptsMade} attempts: ${error.message}`, attemptsMade: attemptsMade };
          }
        }
      }

      // Fallback return if loop exits without returning
      return { error: true, message: `Search failed after ${attemptsMade} attempts`, attemptsMade: attemptsMade };
    }

    async function extractTextFromPDF(file) {
      try {
        const arrayBuffer = await file.arrayBuffer();
        const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
        let fullText = '';
        for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
          const page = await pdf.getPage(pageNum);
          const textContent = await page.getTextContent();
          const pageText = textContent.items.map(item => item.str).join(' ');
          fullText += `--- Page ${pageNum} ---\n${pageText}\n\n`;
        }
        return fullText || 'No text could be extracted from the PDF.';
      } catch (error) {
        return 'Error: Could not extract text from the PDF.';
      }
    }

    function readFileAsText(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = () => reject(reader.error);
        reader.readAsText(file);
      });
    }

    function readFileAsDataURL(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = () => reject(reader.error);
        reader.readAsDataURL(file);
      });
    }

    function updateChatHistory() {
      const sidebarContent = document.querySelector('.sidebar-content');
      if (!sidebarContent) return;
      
      sidebarContent.innerHTML = '';
      const recentChats = chatHistory.slice(-15).reverse();
      
      if (recentChats.length === 0) {
        const emptyMessage = document.createElement('div');
        emptyMessage.classList.add('empty-message');
        emptyMessage.textContent = 'No chat history yet';
        sidebarContent.appendChild(emptyMessage);
        return;
      }
      
      recentChats.forEach((chat, index) => {
        const chatCard = document.createElement('div');
        chatCard.classList.add('chat-card');
        chatCard.innerHTML = `
          <p class="chat-name">${chat.name}</p>
          <button class="menu-btn" aria-label="Chat options">⋮</button>
          <div class="dropdown">
            <button class="delete-btn">Delete</button>
          </div>
        `;
        const menuBtn = chatCard.querySelector('.menu-btn');
        const dropdown = chatCard.querySelector('.dropdown');
        const deleteBtn = chatCard.querySelector('.delete-btn');

        chatCard.addEventListener('click', (e) => {
          if (e.target !== menuBtn && e.target !== deleteBtn) {
            loadChat(chat.messages, chatHistory.length - 1 - index);
            
            // Close sidebar on mobile after selecting a chat
            if (window.innerWidth <= 480) {
              closeAllPanels();
            }
          }
        });

        menuBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          const allDropdowns = document.querySelectorAll('.dropdown');
          allDropdowns.forEach(d => {
            if (d !== dropdown) d.style.display = 'none';
          });
          dropdown.style.display = dropdown.style.display === 'block' ? 'none' : 'block';
        });

        deleteBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          chatHistory.splice(chatHistory.length - 1 - index, 1);
          localStorage.setItem('chatHistory', JSON.stringify(chatHistory));
          updateChatHistory();
          if (currentChatIndex === chatHistory.length - index) {
            conversation = [];
            document.getElementById('chat-container').innerHTML = '';
            currentChatIndex = -1;
          }
        });

        document.addEventListener('click', (e) => {
          if (!chatCard.contains(e.target)) {
            dropdown.style.display = 'none';
          }
        });

        sidebarContent.appendChild(chatCard);
      });
    }

    function updateMemoriesPane() {
      const memoriesContent = document.querySelector('.memories-content');
      if (!memoriesContent) return;
      
      memoriesContent.innerHTML = '';
      const recentMemories = memories.slice(-15).reverse();
      
      if (recentMemories.length === 0) {
        const emptyMessage = document.createElement('div');
        emptyMessage.classList.add('empty-message');
        emptyMessage.textContent = 'No memories saved yet';
        memoriesContent.appendChild(emptyMessage);
        return;
      }
      
      recentMemories.forEach((memory, index) => {
        const memoryCard = document.createElement('div');
        memoryCard.classList.add('memory-card');
        memoryCard.innerHTML = `
          <p class="memory-text">${memory.content}</p>
          <button class="menu-btn" aria-label="Memory options">⋮</button>
          <div class="dropdown">
            <button class="delete-btn">Delete</button>
          </div>
        `;
        const menuBtn = memoryCard.querySelector('.menu-btn');
        const dropdown = memoryCard.querySelector('.dropdown');
        const deleteBtn = memoryCard.querySelector('.delete-btn');

        menuBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          const allDropdowns = document.querySelectorAll('.dropdown');
          allDropdowns.forEach(d => {
            if (d !== dropdown) d.style.display = 'none';
          });
          dropdown.style.display = dropdown.style.display === 'block' ? 'none' : 'block';
        });

        deleteBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          memories.splice(memories.length - 1 - index, 1);
          localStorage.setItem('memories', JSON.stringify(memories));
          updateMemoriesPane();
        });

        document.addEventListener('click', (e) => {
          if (!memoryCard.contains(e.target)) {
            dropdown.style.display = 'none';
          }
        });

        memoriesContent.appendChild(memoryCard);
      });
    }

    function loadChat(messages, index) {
      conversation = messages.slice();
      currentChatIndex = index;
      
      const chatContainer = document.getElementById('chat-container');
      chatContainer.innerHTML = '';
      
      // Add messages to the chat
      conversation.forEach(msg => addMessageToChat(msg.role, msg.content, false));
      
      // Close panels
      closeAllPanels();
      
      // Scroll to the bottom of the chat
      setTimeout(() => {
        chatContainer.scrollTop = chatContainer.scrollHeight;
      }, 100);
    }

    async function saveOrUpdateChat() {
      if (conversation.length) {
        const chatName = await updateChatAndMemories();
        if (currentChatIndex === -1) {
          chatHistory.push({ name: chatName, messages: conversation.slice(), files: [] });
          currentChatIndex = chatHistory.length - 1;
        } else {
          chatHistory[currentChatIndex] = { name: chatName, messages: conversation.slice(), files: [] };
        }
        localStorage.setItem('chatHistory', JSON.stringify(chatHistory));
        updateChatHistory();
      }
    }

    function calculateTextSize(messages) {
      let textContent = '';
      messages.forEach(msg => {
        if (typeof msg.content === 'string') {
          textContent += msg.content;
        } else if (Array.isArray(msg.content)) {
          msg.content.forEach(item => {
            if (item.type === 'text') {
              textContent += item.text;
            }
          });
        }
      });
      return textContent.length;
    }

    document.addEventListener('DOMContentLoaded', function() {
      const userInput = document.getElementById('user-input');
      const sendButton = document.getElementById('send-button');
      const fileInput = document.getElementById('file-input');
      const previewArea = document.getElementById('preview-area');
      const chatContainer = document.getElementById('chat-container');
      const newChatButton = document.getElementById('new-chat-button');
      const sidebarToggle = document.getElementById('sidebar-toggle');
      const memoriesToggle = document.getElementById('memories-toggle');
      const sidebar = document.getElementById('sidebar');
      const memoriesPane = document.getElementById('memories-pane');
      const mainContainer = document.getElementById('main-container');
      const webSearchToggle = document.getElementById('web-search-toggle');
      const overlay = document.querySelector('.overlay');
      const closePanelButtons = document.querySelectorAll('.close-panel');
      const inputArea = document.getElementById('input-area');
      const sidebarContent = document.querySelector('.sidebar-content');
      const memoriesContent = document.querySelector('.memories-content');
      const isMobile = window.innerWidth <= 480;

      // Initialize the UI
      updateChatHistory();
      updateMemoriesPane();
      
      // Function to close all panels
      function closeAllPanels() {
        sidebar.classList.remove('open');
        memoriesPane.classList.remove('open');
        mainContainer.classList.remove('shifted-left', 'shifted-right');
        overlay.classList.remove('active');
        
        // Enable scrolling on main content
        document.body.style.overflow = '';
        chatContainer.style.overflow = 'auto';
      }
      
      // Handle sidebar toggle
      sidebarToggle.addEventListener('click', function() {
        sidebar.classList.toggle('open');
        if (sidebar.classList.contains('open')) {
          memoriesPane.classList.remove('open');
          mainContainer.classList.add('shifted-left');
          mainContainer.classList.remove('shifted-right');
          overlay.classList.add('active');
          
          // Disable scrolling on main content for mobile
          if (isMobile) {
            document.body.style.overflow = 'hidden';
            chatContainer.style.overflow = 'hidden';
          }
        } else {
          mainContainer.classList.remove('shifted-left');
          overlay.classList.remove('active');
          
          // Re-enable scrolling
          document.body.style.overflow = '';
          chatContainer.style.overflow = 'auto';
        }
      });

      // Handle memories toggle
      memoriesToggle.addEventListener('click', function() {
        memoriesPane.classList.toggle('open');
        if (memoriesPane.classList.contains('open')) {
          sidebar.classList.remove('open');
          mainContainer.classList.add('shifted-right');
          mainContainer.classList.remove('shifted-left');
          overlay.classList.add('active');
          
          // Disable scrolling on main content for mobile
          if (isMobile) {
            document.body.style.overflow = 'hidden';
            chatContainer.style.overflow = 'hidden';
          }
        } else {
          mainContainer.classList.remove('shifted-right');
          overlay.classList.remove('active');
          
          // Re-enable scrolling
          document.body.style.overflow = '';
          chatContainer.style.overflow = 'auto';
        }
      });

      // Close panels when clicking on overlay
      overlay.addEventListener('click', closeAllPanels);

      // Close panel buttons
      closePanelButtons.forEach(button => {
        button.addEventListener('click', closeAllPanels);
      });

      // Add a function to scroll to the bottom of the chat
      function scrollToBottom() {
        const chatContainer = document.getElementById('chat-container');
        chatContainer.scrollTop = chatContainer.scrollHeight;
      }
      
      // Ensure chat container scrolls to bottom when new messages are added
      const observer = new MutationObserver(function(mutations) {
        mutations.forEach(function(mutation) {
          if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
            scrollToBottom();
          }
        });
      });
      
      observer.observe(chatContainer, { childList: true });
      
      // Handle window resize to adjust chat container
      window.addEventListener('resize', function() {
        // Update isMobile status
        const wasMobile = isMobile;
        const newIsMobile = window.innerWidth <= 480;
        
        // Only take action if mobile status changed
        if (wasMobile !== newIsMobile) {
          location.reload(); // Reload to apply correct layout
        } else {
          // Just adjust margins and scroll position
          if (newIsMobile) {
            chatContainer.style.marginBottom = (inputArea.offsetHeight + 10) + 'px';
          }
          scrollToBottom();
        }
      });

      // Handle input area on mobile
      if (isMobile) {
        // Adjust textarea height based on content
        userInput.addEventListener('input', function() {
          this.style.height = 'auto';
          const newHeight = Math.min(this.scrollHeight, 100);
          this.style.height = newHeight + 'px';
          
          // Adjust chat container bottom margin
          chatContainer.style.marginBottom = (inputArea.offsetHeight + 10) + 'px';
        });
        
        // Handle focus/blur for better mobile experience
        userInput.addEventListener('focus', function() {
          // Scroll chat to bottom when focusing on input
          setTimeout(scrollToBottom, 300);
          
          if (previewArea.children.length > 0) {
            previewArea.style.display = 'flex';
          }
          
          // Add class to body for keyboard open state
          document.body.classList.add('keyboard-open');
        });
        
        userInput.addEventListener('blur', function() {
          if (previewArea.children.length === 0) {
            previewArea.style.display = 'none';
          }
          
          // Remove keyboard open class
          document.body.classList.remove('keyboard-open');
        });
        
        // Handle orientation change
        window.addEventListener('orientationchange', function() {
          setTimeout(function() {
            // Adjust chat container bottom margin
            chatContainer.style.marginBottom = (inputArea.offsetHeight + 10) + 'px';
            
            // Scroll to bottom after orientation change
            scrollToBottom();
          }, 300);
        });
      }

      // Handle file input
      fileInput.addEventListener('change', (event) => {
      const files = Array.from(event.target.files);
      if (!files.length) return;

      previewArea.innerHTML = '';

      files.forEach(file => {
        const fileCard = document.createElement('div');
        fileCard.classList.add('file-card');
        fileCard.innerHTML = `<span>${file.name}</span>`;
        if (file.type.startsWith('image/')) {
          const reader = new FileReader();
          reader.onload = function(e) {
            const img = document.createElement('img');
            img.src = e.target.result;
            fileCard.appendChild(img);
          };
          reader.readAsDataURL(file);
        }
        previewArea.appendChild(fileCard);
      });
    });

      // Handle send button
      sendButton.addEventListener('click', async () => {
        await handleUserInput();
      });

      // Handle user input
      userInput.addEventListener('keydown', async (event) => {
        if (event.key === 'Enter' && !event.shiftKey) {
          event.preventDefault();
          await handleUserInput();
        }
      });

      // Handle new chat button
      newChatButton.addEventListener('click', () => {
        startNewChat();
      });

      // Handle model selection
      const modelSelectButton = document.getElementById('model-select-button');
      const modelSelectDropdown = document.getElementById('model-select-dropdown');
      
      modelSelectButton.addEventListener('click', () => {
        modelSelectDropdown.style.display = modelSelectDropdown.style.display === 'block' ? 'none' : 'block';
      });

      modelSelectDropdown.querySelectorAll('button').forEach(button => {
        button.addEventListener('click', () => {
          selectedModel = button.getAttribute('data-value');
          modelSelectButton.textContent = button.textContent;
          modelSelectDropdown.style.display = 'none';
        });
      });

      // Close model dropdown when clicking outside
      document.addEventListener('click', (event) => {
        if (!event.target.closest('.model-select-container')) {
          modelSelectDropdown.style.display = 'none';
        }
      });

      updateUserInfo();
    });

    // Handle user input submission
    async function handleUserInput() {
      const userText = document.getElementById('user-input').value.trim();
      const webSearchEnabled = document.getElementById('web-search-toggle').checked;
      const fileInput = document.getElementById('file-input');
      const files = fileInput.files ? Array.from(fileInput.files) : [];
      const previewArea = document.getElementById('preview-area');

      console.log('Processing user input. Text:', userText, 'Files:', files.length);

      if (!userText && files.length === 0) {
        console.log('No text or files to send. Aborting.');
        return;
      }

      let totalTextChars = calculateTextSize(conversation);
      console.log('Initial text size:', totalTextChars);

      if (files.length > 0) {
        for (const file of files) {
          console.log('Processing file:', file.name);
          if (file.type.startsWith('image/')) {
            const dataUrl = await readFileAsDataURL(file);
            const imageMessage = {"role": "user", "content": [{"type": "image_url", "image_url": {"url": dataUrl}}]};
            addMessageToChat('user', imageMessage.content);
            conversation.push(imageMessage);
            console.log('Added image to conversation:', file.name);
          } else if (file.type === 'application/pdf') {
            const text = await extractTextFromPDF(file);
            totalTextChars += text.length;
            addMessageToChat('user', `Uploaded file: ${file.name}`);
            conversation.push({"role": "user", "content": `Uploaded file: ${file.name}\nContent:\n${text}`});
            console.log('Added PDF to conversation:', file.name);
          } else {
            const text = await readFileAsText(file);
            totalTextChars += text.length;
            addMessageToChat('user', `Uploaded file: ${file.name}`);
            conversation.push({"role": "user", "content": `Uploaded file: ${file.name}\nContent:\n${text}`});
            console.log('Added text file to conversation:', file.name);
          }
        }
      }

      if (userText) {
        const textMessage = {"role": "user", "content": userText};
        totalTextChars += userText.length;
        addMessageToChat('user', userText);
        conversation.push(textMessage);
        console.log('Added text to conversation:', userText);
      }

      if (totalTextChars > MAX_CHARS) {
        console.log('Text size exceeds limit:', totalTextChars);
        addErrorMessage('Oops! The conversation text exceeds the 512,000 character limit. Please start a new chat.');
        return;
      }

      console.log('Clearing input and preview area');
      document.getElementById('user-input').value = '';
      previewArea.innerHTML = '';
      fileInput.value = '';

      let systemMessage = null;
      const currentDateTime = new Date().toLocaleString('en-US', { 
        year: 'numeric', 
        month: 'long', 
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        timeZoneName: 'short'
      });
      const isMathRequest = /\d\s*[\+\-\*\/]\s*\d|\b(math|calculate)\b/i.test(userText);
      const isSpotifyRequest = /\b(spotify|song|track|album|playlist|music|artist)\b/i.test(userText);
      const memoryContext = memories.map(m => m.content).join('\n');
      const memoryInstructions = `I can memorize key details you share across all chats and use them to assist you better. You can ask me to forget specific memories or all memories by saying "forget [specific detail]" or "forget everything". View or delete them manually via the Memories tab (🧠).`;

      if (webSearchEnabled || isMathRequest) {
        const searchLoadingMessage = isMathRequest ? addThinkingMessage() : addSearchLoadingMessage();
        
        console.log('Starting web search');
        // First, perform the main web search
        const webSearchResult = webSearchEnabled ? await tryWebSearch(userText, 3, false, false) : { error: true, attemptsMade: 0, needsYouTube: false, needsSpotify: false };
        
        // Initialize these properties if they don't exist
        if (webSearchResult.needsYouTube === undefined) webSearchResult.needsYouTube = false;
        if (webSearchResult.needsSpotify === undefined) webSearchResult.needsSpotify = false;
        
        // Check if this is a direct music request
        const musicKeywords = ['song', 'music', 'track', 'artist', 'band', 'album', 'playlist', 'spotify', 'listen', 'play'];
        const isDirectMusicRequest = musicKeywords.some(keyword => userText.toLowerCase().includes(keyword));
        
        // For direct Spotify requests or music-related queries, set the flag
        if ((isSpotifyRequest || isDirectMusicRequest) && !webSearchResult.needsSpotify) {
          webSearchResult.needsSpotify = true;
          
          // For direct Spotify requests, use the official Spotify API
          // Pass an empty string as web search results since we don't have any
          spotifySearchResult = await trySpotifySearch(userText, 3, "");
        }
        
        // Only make YouTube/Spotify searches if the main search indicates they're needed
        let youtubeSearchResult = { error: true, attemptsMade: 0 };
        let spotifySearchResult = { error: true, attemptsMade: 0 };
        
        if (webSearchEnabled && !webSearchResult.error && webSearchResult.needsYouTube) {
          // Make up to 3 attempts for YouTube search
          youtubeSearchResult = await tryWebSearch(userText, 3, true, false);
        }
        
        if (webSearchEnabled && !webSearchResult.error && webSearchResult.needsSpotify) {
          // Make up to 3 attempts for Spotify search using the official API
          const webSearchSummary = webSearchResult.result ? webSearchResult.result.substring(0, 500) : "";
          spotifySearchResult = await trySpotifySearch(userText, 3, webSearchSummary);
        }

        // No more retries for YouTube/Spotify search
        removeLoadingMessage(searchLoadingMessage);

        let combinedResults = '';
        let youtubeEmbed = '';
        let spotifyEmbed = '';
        
        // Process web search results
        if (!webSearchResult.error && webSearchResult.result) {
          combinedResults += `${webSearchResult.result}\n`;
        } else {
          console.log('Web search failed after all attempts');
          combinedResults += `Web search feature failed after ${webSearchResult.attemptsMade} attempts. `;
        }
        
        // Process YouTube results
        if (!youtubeSearchResult.error && youtubeSearchResult.result && youtubeSearchResult.result.youtube_url) {
          const videoIdMatch = youtubeSearchResult.result.youtube_url.match(/v=([^&]+)/);
          if (videoIdMatch && videoIdMatch[1]) {
            const videoId = videoIdMatch[1];
            
            // Validate the YouTube URL by attempting to fetch it
            try {
              const response = await fetch(`https://www.youtube.com/oembed?url=https://www.youtube.com/watch?v=${videoId}`, { 
                method: 'HEAD'
              });
              
              if (response.ok) {
                // Create the embed iframe
                youtubeEmbed = `<iframe class="youtube-embed" width="560" height="315" src="https://www.youtube.com/embed/${videoId}?si=FhIchvTjZVmMrvti" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>`;
                combinedResults += `\n${youtubeEmbed}\nRelevant YouTube video: ${youtubeSearchResult.result.youtube_url} - ${youtubeSearchResult.result.title || ''}\n`;
                
                console.log(`Successfully validated and embedded YouTube video: ${videoId}`);
              } else {
                console.error(`YouTube video exists but cannot be embedded: ${videoId}`);
                combinedResults += `\nRelevant YouTube video: ${youtubeSearchResult.result.youtube_url} - ${youtubeSearchResult.result.title || ''}\n`;
              }
            } catch (error) {
              console.error(`Failed to validate YouTube URL: ${error.message}`);
              combinedResults += `\nRelevant YouTube video: ${youtubeSearchResult.result.youtube_url} - ${youtubeSearchResult.result.title || ''}\n`;
            }
          } else {
            console.log('Invalid YouTube URL format received');
            combinedResults += `\nRelevant YouTube video: ${youtubeSearchResult.result.youtube_url} - ${youtubeSearchResult.result.title || ''}\n`;
          }
        } else if (webSearchResult.needsYouTube) {
          console.log('YouTube search failed after attempts');
          combinedResults += `YouTube search feature failed after ${youtubeSearchResult.attemptsMade} attempts. `;
        }
        
        // Process Spotify results
        if (!spotifySearchResult.error && spotifySearchResult.result && spotifySearchResult.result.spotify_url) {
          const contentType = spotifySearchResult.result.type || 'track';
          const spotifyUrlPattern = /spotify\.com\/(track|album|playlist|artist)\/([a-zA-Z0-9]+)/;
          const spotifyMatch = spotifySearchResult.result.spotify_url.match(spotifyUrlPattern);
          
          if (spotifyMatch && spotifyMatch[1] && spotifyMatch[2]) {
            const contentType = spotifyMatch[1];
            const contentId = spotifyMatch[2];
            
            // Adjust height based on content type
            let height = 152; // Default for tracks
            if (contentType === 'album') height = 232;
            if (contentType === 'playlist') height = 352;
            if (contentType === 'artist') height = 352;
            
            // Create the embed iframe using the content type and ID
            spotifyEmbed = `<iframe class="spotify-embed" style="border-radius:12px" src="https://open.spotify.com/embed/${contentType}/${contentId}?utm_source=generator" width="100%" height="${height}" frameBorder="0" allowfullscreen="" allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture" loading="lazy"></iframe>`;
            
            combinedResults += `\n${spotifyEmbed}\nSpotify ${contentType}: ${spotifySearchResult.result.title}\n`;
            console.log(`Successfully embedded Spotify ${contentType}: ${contentId}`);
          } else {
            // Fallback to direct link if URL format is invalid
            console.log('Invalid Spotify URL format, providing direct link instead');
            combinedResults += `\nSpotify content: [${spotifySearchResult.result.title}](${spotifySearchResult.result.spotify_url})\n`;
          }
        } else if (webSearchResult.needsSpotify) {
          console.log('Spotify search failed after attempts');
          combinedResults += `Spotify search feature failed after ${spotifySearchResult.attemptsMade} attempts. `;
        }

        systemMessage = {
          "role": "system",
          "content": isMathRequest
            ? `${memoryInstructions}\nCurrent date and time: ${currentDateTime}. Answer the user's math question in a single, concise line (e.g., "$$3 - 6 = -3$$") unless more explanation is explicitly requested. Use LaTeX notation (e.g., $$...$$) for all equations, ensuring proper rendering with no extra spacing or paragraphs around math. Verify each step and double-check the final result for accuracy. User language: ${userLanguage}, City: ${userCity}. Memories: ${memoryContext}. You can see, edit, delete, or add to these memories based on the conversation.`
            : `${memoryInstructions}\nCurrent date and time: ${currentDateTime}. You have access to the following search results: ${combinedResults}. Use this information to answer the user's question with current details. Provide comprehensive, detailed, and well-structured responses with thorough explanations. Mark nearly every fact with a compact source reference as "[Q[NUMBER]]" (e.g., "Tesla produced 10,000 Cybertrucks in 2025 Q2 [Q1]"). Number sources sequentially. Ensure the [Q[NUMBER]] in the text directly links to the corresponding URL in the sources list (example: [Q1](https://tesla.com/news)). ${youtubeEmbed ? 'I have included a relevant YouTube video in the response. Reference it in your answer if appropriate.' : ''} ${spotifyEmbed ? 'I have included relevant Spotify content in the response. Reference it in your answer if appropriate.' : ''} For mathematical questions, answer in a single, concise line (e.g., "$$3 - 6 = -3$$") unless more explanation is requested. Use LaTeX notation (e.g., $$...$$) for equations with no extra spacing. Verify each step and double-check the final result for accuracy. User language: ${userLanguage}, City: ${userCity}. Memories: ${memoryContext}. You can see, edit, delete, or add to these memories based on the conversation.`
        };
      } else {
        systemMessage = {
          "role": "system",
          "content": `${memoryInstructions}\nCurrent date and time: ${currentDateTime}. Answer the user's question with comprehensive, detailed, and well-structured responses. If needed use headings (###) and lists (-). If sources are available or relevant, mark facts with compact references as [Q[NUMBER]] (e.g., "[Q1]"). Ensure the [Number] in the text directly links to the corresponding URL (example: [Q1](https://tesla.com/news)). For mathematical questions, answer in a single, concise line (e.g., "$$3 - 6 = -3$$") unless more explanation is requested. Use LaTeX notation (e.g., $$...$$) for equations with no extra spacing. Verify each step and double-check the final result for accuracy. User language: ${userLanguage}, City: ${userCity}. Memories: ${memoryContext}. You can see, edit, delete, or add to these memories based on the conversation.`
        };
      }

      console.log('Sending AI request');
      const thinkingMessage = addThinkingMessage();
      try {
        const messages = systemMessage ? [systemMessage, ...conversation] : conversation;
        const response = await fetch('https://text.pollinations.ai/', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            messages: messages,
            model: selectedModel,
            seed: getRandomSeed(),
            private: true
          })
        });
        const data = await response.text();
        removeLoadingMessage(thinkingMessage);
        addMessageToChat('assistant', data);
        conversation.push({"role": "assistant", "content": data});
        await saveOrUpdateChat();
        console.log('AI response received and added:', data);

        if (userText && userText.toLowerCase().includes('forget everything')) {
          memories = [];
          localStorage.setItem('memories', JSON.stringify(memories));
          updateMemoriesPane();
        } else if (userText && userText.toLowerCase().includes('forget')) {
          const toForget = userText.toLowerCase().replace('forget', '').trim();
          memories = memories.filter(m => !m.content.toLowerCase().includes(toForget));
          localStorage.setItem('memories', JSON.stringify(memories));
          updateMemoriesPane();
        }
      } catch (error) {
        removeLoadingMessage(thinkingMessage);
        addMessageToChat('assistant', 'Sorry, an error occurred while retrieving the response.');
        console.error('AI request failed:', error);
      }
    }

    // Start a new chat
    function startNewChat() {
      conversation = [];
      document.getElementById('chat-container').innerHTML = '';
      document.getElementById('user-input').value = '';
      document.getElementById('preview-area').innerHTML = '';
      document.getElementById('file-input').value = '';
      sources = [];
      currentChatIndex = -1;
      
      const sidebar = document.getElementById('sidebar');
      const memoriesPane = document.getElementById('memories-pane');
      const mainContainer = document.getElementById('main-container');
      const overlay = document.querySelector('.overlay');
      
      sidebar.classList.remove('open');
      memoriesPane.classList.remove('open');
      mainContainer.classList.remove('shifted-left', 'shifted-right');
      overlay.classList.remove('active');
    }

    // Add Spotify API functions
    async function getSpotifyAccessToken() {
      const clientId = 'd161f89df56b4e98ab2fa92bf3897fe6';
      const clientSecret = 'a91703929d884228b1e9c31870ade978';
      
      try {
        const response = await fetch('https://accounts.spotify.com/api/token', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            'Authorization': 'Basic ' + btoa(clientId + ':' + clientSecret)
          },
          body: 'grant_type=client_credentials'
        });
        
        if (!response.ok) {
          throw new Error(`Failed to get Spotify token: ${response.status}`);
        }
        
        const data = await response.json();
        return data.access_token;
      } catch (error) {
        console.error('Error getting Spotify access token:', error);
        return null;
      }
    }
    
    async function searchSpotify(query, type = 'track,album,playlist', limit = 1) {
      try {
        const token = await getSpotifyAccessToken();
        if (!token) {
          throw new Error('Failed to get Spotify access token');
        }
        
        // Encode the query properly
        const encodedQuery = encodeURIComponent(query);
        const url = `https://api.spotify.com/v1/search?q=${encodedQuery}&type=${type}&limit=${limit}`;
        
        const response = await fetch(url, {
          method: 'GET',
          headers: {
            'Authorization': `Bearer ${token}`
          }
        });
        
        if (!response.ok) {
          throw new Error(`Spotify search failed: ${response.status}`);
        }
        
        const data = await response.json();
        
        // Check for track results first (highest priority)
        if (data.tracks && data.tracks.items && data.tracks.items.length > 0) {
          const track = data.tracks.items[0];
          return {
            id: track.id,
            name: track.name,
            artist: track.artists[0].name,
            album: track.album.name,
            url: track.external_urls.spotify,
            type: 'track'
          };
        } 
        // Check for album results
        else if (data.albums && data.albums.items && data.albums.items.length > 0) {
          const album = data.albums.items[0];
          return {
            id: album.id,
            name: album.name,
            artist: album.artists[0].name,
            url: album.external_urls.spotify,
            type: 'album'
          };
        }
        // Check for playlist results
        else if (data.playlists && data.playlists.items && data.playlists.items.length > 0) {
          const playlist = data.playlists.items[0];
          return {
            id: playlist.id,
            name: playlist.name,
            artist: playlist.owner.display_name,
            url: playlist.external_urls.spotify,
            type: 'playlist'
          };
        } else {
          return null;
        }
      } catch (error) {
        console.error('Error searching Spotify:', error);
        return null;
      }
    }
    
    // Function to extract song and artist using OpenAI
    async function extractSongInfo(query, webSearchResults = "") {
      try {
        const systemPrompt = `You are a music identification assistant. Extract the most likely song title and artist name from the user's query and any provided web search results. 
        
IMPORTANT GUIDELINES:
1. Analyze both the query and web search results for music references
2. Look for mentions of songs, artists, albums, genres, eras, or musical themes
3. Prioritize explicit song requests ("play X by Y") over general topics
4. For general topics (e.g., "music for studying"), identify a specific relevant song
5. Consider cultural context, time periods, and emotional themes

ONLY respond in this exact JSON format:
{"song": "SONG_TITLE", "artist": "ARTIST_NAME", "type": "track|album|playlist", "reason": "Brief explanation of why this is relevant"}

If you can't identify both a song title and artist with reasonable confidence, respond with:
{"song": null, "artist": null, "type": null, "reason": "Explanation of why no music could be identified"}

Examples:
1. For "Play Bohemian Rhapsody by Queen" → {"song": "Bohemian Rhapsody", "artist": "Queen", "type": "track", "reason": "Direct request for this specific song"}
2. For "I want to listen to Yesterday" → {"song": "Yesterday", "artist": "The Beatles", "type": "track", "reason": "Clear request for this classic song"}
3. For "Tell me about Michael Jackson and play Billie Jean" → {"song": "Billie Jean", "artist": "Michael Jackson", "type": "track", "reason": "Explicit song request within query about the artist"}
4. For "Music for studying" → {"song": "Study Playlist", "artist": "Various Artists", "type": "playlist", "reason": "General request for study music is best served by a playlist"}
5. For "What's the capital of France?" → {"song": null, "artist": null, "type": null, "reason": "Query is unrelated to music"}`;

        const userPrompt = `Query: ${query}\n\nWeb search results: ${webSearchResults.substring(0, 1000)}`;

        const response = await fetch('https://text.pollinations.ai/', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            messages: [
              {"role": "system", "content": systemPrompt},
              {"role": "user", "content": userPrompt}
            ],
            model: 'openai',
            jsonMode: true,
            private: true
          })
        });

        if (!response.ok) {
          throw new Error(`API call failed with status ${response.status}`);
        }

        const result = await response.json();
        console.log("Song extraction result:", result);
        
        // Check if we have valid song and artist
        if (result && result.song && result.artist) {
          // If it's a playlist request, modify the search query
          if (result.type === 'playlist') {
            return `${result.song} playlist ${result.artist}`;
          }
          return `${result.song} ${result.artist}`;
        } else if (result && result.song) {
          return result.song;
        } else if (result && result.artist) {
          return `${result.artist} popular songs`;
        } else {
          // If extraction failed, return the original query
          return query;
        }
      } catch (error) {
        console.error("Error extracting song info:", error);
        return query; // Return original query if extraction fails
      }
    }
    
    // Replace the Spotify search function
    async function trySpotifySearch(query, maxAttempts = 3, webSearchResults = "") {
      let attempts = 0;
      
      // First, use OpenAI to extract the song and artist
      const extractedQuery = await extractSongInfo(query, webSearchResults);
      console.log(`Extracted music query: "${extractedQuery}" from original: "${query}"`);
      
      while (attempts < maxAttempts) {
        attempts++;
        try {
          console.log(`Spotify API search attempt ${attempts} for: ${extractedQuery}`);
          
          // Try to find a track
          const result = await searchSpotify(extractedQuery);
          
          if (result) {
            console.log(`Spotify search successful:`, result);
            return { 
              error: false, 
              result: { 
                spotify_url: result.url, 
                title: `${result.name} - ${result.artist}`, 
                type: result.type,
                id: result.id
              }, 
              attemptsMade: attempts 
            };
          } else {
            console.log(`No results found for "${extractedQuery}" on attempt ${attempts}`);
            
            // If this is the last attempt and we have both song and artist, try just the song
            if (attempts === maxAttempts - 1 && extractedQuery.includes(" ")) {
              // Try with just the first part (likely the song title)
              const simplifiedQuery = extractedQuery.split(" ")[0];
              console.log(`Trying simplified search with: "${simplifiedQuery}"`);
              const simpleResult = await searchSpotify(simplifiedQuery);
              
              if (simpleResult) {
                console.log(`Simplified Spotify search successful:`, simpleResult);
                return { 
                  error: false, 
                  result: { 
                    spotify_url: simpleResult.url, 
                    title: `${simpleResult.name} - ${simpleResult.artist}`, 
                    type: simpleResult.type,
                    id: simpleResult.id
                  }, 
                  attemptsMade: attempts 
                };
              }
            }
            
            if (attempts < maxAttempts) {
              await new Promise(resolve => setTimeout(resolve, 1000));
              continue;
            }
          }
        } catch (error) {
          console.error(`Spotify search attempt ${attempts} failed:`, error);
          if (attempts < maxAttempts) {
            await new Promise(resolve => setTimeout(resolve, 1000));
            continue;
          }
        }
      }
      
      // If all attempts failed, return error
      return { 
        error: true, 
        message: `No Spotify results found after ${attempts} attempts`, 
        attemptsMade: attempts 
      };
    }
  </script>
</body>
</html>
