<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>VynAI</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-MML-AM_CHTML"></script>
  <style>
    :root {
      --background-color: #0d1117;
      --chat-background: #161b22;
      --text-color: #e6edf3;
      --user-message-bg: #238636;
      --assistant-message-bg: #21262d;
      --primary-color: #238636;
      --secondary-color: #30363d;
      --border-radius: 12px;
      --shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      --code-bg: #1a1e24;
      --error-bg: #ff4444;
      --transition-speed: 0.3s;
      --accent-color: #58a6ff;
      --hover-color: #2ea043;
    }
    * {
      box-sizing: border-box;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: var(--background-color);
      color: var(--text-color);
      display: flex;
      flex-direction: row;
      height: 100vh;
      gap: 20px;
      transition: background-color var(--transition-speed) ease;
    }
    #sidebar, #memories-pane {
      width: 0;
      height: calc(100vh - 40px);
      position: fixed;
      z-index: 20;
      top: 20px;
      background-color: var(--secondary-color);
      overflow-x: hidden;
      overflow-y: auto;
      transition: width var(--transition-speed) ease, transform var(--transition-speed) ease;
      padding: 20px 0;
      border-radius: var(--border-radius);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }
    #sidebar {
      left: 20px;
    }
    #memories-pane {
      right: 20px;
    }
    #sidebar.open, #memories-pane.open {
      width: 300px;
      padding: 20px;
    }
    #sidebar .chat-card, #memories-pane .memory-card {
      background-color: var(--chat-background);
      padding: 15px;
      margin-bottom: 15px;
      border-radius: 8px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
      position: relative;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease, background-color 0.2s ease;
      border-left: 3px solid transparent;
    }
    #sidebar .chat-card:hover, #memories-pane .memory-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.25);
      border-left: 3px solid var(--primary-color);
    }
    #sidebar .chat-name, #memories-pane .memory-text {
      font-size: 16px;
      color: var(--text-color);
      margin: 0;
    }
    #sidebar .chat-card .menu-btn, #memories-pane .memory-card .menu-btn {
      position: absolute;
      top: 10px;
      right: 10px;
      background: none;
      border: none;
      color: var(--text-color);
      font-size: 20px;
      padding: 5px;
      cursor: pointer;
      transition: color 0.2s ease;
    }
    #sidebar .chat-card .menu-btn:hover, #memories-pane .memory-card .menu-btn:hover {
      color: var(--primary-color);
    }
    #sidebar .chat-card .dropdown, #memories-pane .memory-card .dropdown {
      display: none;
      position: absolute;
      top: 35px;
      right: 0;
      background-color: #2a2f38;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
      border-radius: 8px;
      z-index: 10;
      padding: 5px 0;
      min-width: 120px;
    }
    #sidebar .chat-card .dropdown button, #memories-pane .memory-card .dropdown button {
      display: block;
      width: 100%;
      padding: 10px 15px;
      background: none;
      border: none;
      color: #ff6666;
      text-align: left;
      cursor: pointer;
      font-size: 14px;
      transition: background-color 0.2s ease;
    }
    #sidebar .chat-card .dropdown button:hover, #memories-pane .memory-card .dropdown button:hover {
      background-color: var(--primary-color);
      color: #ffffff;
    }
    #main-container {
      flex-grow: 1;
      display: flex;
      flex-direction: column;
      max-width: 1200px;
      margin: 0 auto;
      transition: margin-left 0.3s ease, margin-right 0.3s ease;
      min-height: 0;
    }
    #main-container.shifted-left {
      margin-left: 340px;
    }
    #main-container.shifted-right {
      margin-right: 340px;
    }
    #controls {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 20px;
      margin-bottom: 20px;
      background-color: var(--secondary-color);
      padding: 15px 20px;
      border-radius: var(--border-radius);
      box-shadow: var(--shadow);
      position: sticky;
      top: 20px;
      z-index: 10;
    }
    #controls label {
      font-weight: 600;
      font-size: 14px;
      color: #8b949e;
      margin-right: 10px;
    }
    #chat-container {
      flex-grow: 1;
      overflow-y: auto;
      border: 1px solid #30363d;
      border-radius: var(--border-radius);
      padding: 20px;
      background-color: var(--chat-background);
      margin-bottom: 20px;
      box-shadow: var(--shadow);
      position: relative;
      scroll-behavior: smooth;
    }
    #chat-container::-webkit-scrollbar {
      width: 8px;
    }
    #chat-container::-webkit-scrollbar-track {
      background: var(--background-color);
      border-radius: 4px;
    }
    #chat-container::-webkit-scrollbar-thumb {
      background: var(--secondary-color);
      border-radius: 4px;
    }
    #chat-container::-webkit-scrollbar-thumb:hover {
      background: var(--primary-color);
    }
    .message {
      margin-bottom: 15px;
      max-width: 85%;
      font-size: 16px;
      position: relative;
      animation: fadeInUp 0.3s ease-out;
    }
    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    .message.user {
      margin-left: auto;
      text-align: right;
    }
    .message.assistant {
      margin-right: auto;
      text-align: left;
    }
    .message-content {
      display: inline-block;
      padding: 12px 16px;
      border-radius: var(--border-radius);
      word-wrap: break-word;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
    }
    .message.user .message-content {
      background-color: var(--user-message-bg);
      border-top-right-radius: 4px;
      position: relative;
    }
    .message.user .message-content::after {
      content: '';
      position: absolute;
      right: -10px;
      top: 0;
      width: 0;
      height: 0;
      border-top: 10px solid var(--user-message-bg);
      border-right: 10px solid transparent;
    }
    .message.assistant .message-content {
      background-color: var(--assistant-message-bg);
      border-top-left-radius: 4px;
      position: relative;
    }
    .message.assistant .message-content::after {
      content: '';
      position: absolute;
      left: -10px;
      top: 0;
      width: 0;
      height: 0;
      border-top: 10px solid var(--assistant-message-bg);
      border-left: 10px solid transparent;
    }
    .message span {
      display: block;
    }
    @keyframes fadeIn {
      to {
        opacity: 1;
      }
    }
    .message img {
      max-width: 100%;
      height: auto;
      border-radius: 6px;
      margin-top: 8px;
    }
    .message iframe {
      max-width: 100%;
      border-radius: 6px;
      margin-top: 8px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
      aspect-ratio: 16 / 9;
      width: 560px;
      height: 315px;
      transition: transform 0.3s ease;
    }
    .message iframe:hover {
      transform: scale(1.02);
    }
    .message h1, .message h2, .message h3, .message h4, .message h5, .message h6 {
      margin: 8px 0 4px;
      color: #ffffff;
    }
    .message h1 { font-size: 24px; }
    .message h2 { font-size: 22px; }
    .message h3 { font-size: 20px; }
    .message h4 { font-size: 18px; }
    .message h5 { font-size: 16px; }
    .message h6 { font-size: 14px; }
    .message ul, .message ol {
      margin: 4px 0 4px 20px;
      padding-left: 10px;
    }
    .message li {
      margin-bottom: 4px;
      font-size: 15px;
    }
    .message a {
      color: #58a6ff;
      text-decoration: none;
    }
    .message a:hover {
      text-decoration: underline;
    }
    .message sup a {
      font-size: 0.8em;
      margin-left: 2px;
      vertical-align: super;
    }
    .message hr {
      border: 0;
      border-top: 1px solid #30363d;
      margin: 8px 0;
    }
    .message pre {
      background-color: #161b22;
      padding: 10px;
      border-radius: 6px;
      overflow-x: auto;
      font-size: 14px;
      margin: 8px 0;
    }
    .message code {
      background-color: #161b22;
      padding: 2px 5px;
      border-radius: 4px;
      font-size: 14px;
    }
    .code-card {
      background-color: var(--code-bg);
      padding: 10px;
      border-radius: 8px;
      position: relative;
      margin: 8px 0;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
    }
    .code-card pre {
      margin: 0;
      white-space: pre-wrap;
      font-family: 'Courier New', Courier, monospace;
    }
    .code-card .copy-btn {
      position: absolute;
      top: 10px;
      right: 10px;
      padding: 5px 10px;
      background-color: var(--primary-color);
      color: var(--text-color);
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
    }
    .code-card .copy-btn:hover {
      background-color: #1f6e2d;
    }
    .thinking, .searching {
      background-color: var(--assistant-message-bg);
      color: #8b949e;
      padding: 10px 15px;
      border-radius: var(--border-radius);
      max-width: 85%;
      margin-right: auto;
      box-shadow: var(--shadow);
      font-size: 15px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .thinking::before {
      content: "ü§î";
    }
    .searching::before {
      content: "üîç";
    }
    .thinking span, .searching span {
      animation: blink 1s infinite;
    }
    @keyframes blink {
      50% { opacity: 0.5; }
    }
    .error-message {
      background-color: var(--error-bg);
      color: #ffffff;
      padding: 12px 16px;
      border-radius: var(--border-radius);
      max-width: 85%;
      margin-right: auto;
      box-shadow: var(--shadow);
      font-size: 15px;
      text-align: center;
      animation: slideIn 0.3s ease-in-out;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .error-message::before {
      content: "‚ö†Ô∏è";
      font-size: 18px;
    }
    @keyframes slideIn {
      from { transform: translateY(-20px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }
    #input-area {
      display: flex;
      gap: 10px;
      align-items: center;
      background-color: var(--secondary-color);
      padding: 15px 20px;
      border-radius: var(--border-radius);
      box-shadow: var(--shadow);
      position: sticky;
      bottom: 20px;
      z-index: 10;
      flex-wrap: nowrap;
    }
    #preview-area {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-shrink: 0;
      max-width: 300px;
      overflow-x: auto;
    }
    .file-card {
      background-color: #30363d;
      padding: 5px;
      border-radius: 6px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 3px;
      width: 60px;
      flex-shrink: 0;
    }
    .file-card span {
      max-width: 50px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      font-size: 10px;
      text-align: center;
    }
    .file-card img {
      width: 40px;
      height: 40px;
      object-fit: cover;
      border-radius: 4px;
    }
    #user-input {
      flex-grow: 1;
      padding: 10px 15px;
      background-color: #0d1117;
      color: var(--text-color);
      border: 1px solid #30363d;
      border-radius: var(--border-radius);
      font-size: 16px;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
      min-height: 50px;
      resize: none;
      line-height: 1.5;
    }
    #user-input:focus {
      outline: none;
      border-color: var(--primary-color);
      box-shadow: 0 0 5px rgba(35, 134, 54, 0.5);
    }
    #send-button, #file-input-label, #new-chat-button, #sidebar-toggle, #memories-toggle {
      padding: 10px 20px;
      border: none;
      border-radius: var(--border-radius);
      background-color: var(--primary-color);
      color: var(--text-color);
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      transition: background-color 0.2s ease, transform 0.1s ease, box-shadow 0.2s ease;
      flex-shrink: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 5px;
    }
    #send-button:hover, #file-input-label:hover, #new-chat-button:hover, #sidebar-toggle:hover, #memories-toggle:hover {
      background-color: var(--hover-color);
      transform: translateY(-1px);
      box-shadow: 0 2px 8px rgba(35, 134, 54, 0.4);
    }
    #send-button:active, #file-input-label:active, #new-chat-button:active, #sidebar-toggle:active, #memories-toggle:active {
      transform: translateY(0);
      box-shadow: none;
    }
    #file-input {
      display: none;
    }
    .switch-container {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-shrink: 0;
    }
    .switch {
      position: relative;
      display: inline-block;
      width: 50px;
      height: 24px;
    }
    .switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #30363d;
      transition: .3s;
      border-radius: var(--border-radius);
    }
    .slider:before {
      position: absolute;
      content: "";
      height: 18px;
      width: 18px;
      left: 3px;
      bottom: 3px;
      background-color: #e6edf3;
      transition: .3s;
      border-radius: 50%;
    }
    input:checked + .slider {
      background-color: var(--primary-color);
    }
    input:checked + .slider:before {
      transform: translateX(26px);
    }
    .switch-label {
      font-size: 14px;
      color: #8b949e;
      font-weight: 500;
    }
    .model-select-container {
      position: relative;
      display: inline-block;
    }
    .model-select-button {
      padding: 10px 15px;
      background-color: var(--secondary-color);
      color: var(--text-color);
      border: 1px solid #30363d;
      border-radius: var(--border-radius);
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      transition: background-color 0.2s ease, box-shadow 0.2s ease;
    }
    .model-select-button:hover {
      background-color: #39414a;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
    }
    .model-select-dropdown {
      display: none;
      position: absolute;
      background-color: var(--chat-background);
      min-width: 160px;
      box-shadow: var(--shadow);
      z-index: 100;
      border-radius: var(--border-radius);
      border: 1px solid #30363d;
    }
    .model-select-dropdown button {
      color: var(--text-color);
      padding: 10px 15px;
      text-decoration: none;
      display: block;
      background-color: transparent;
      border: none;
      width: 100%;
      text-align: left;
      cursor: pointer;
      font-size: 14px;
      transition: background-color 0.2s ease;
    }
    .model-select-dropdown button:hover {
      background-color: var(--primary-color);
    }
    #sidebar-label, #memories-label {
      font-size: 18px;
      font-weight: 600;
      color: var(--text-color);
      margin: 0 0 15px 15px;
    }
    @keyframes memoryPulse {
      0% { background-color: var(--chat-background); }
      50% { background-color: #2a2f38; }
      100% { background-color: var(--chat-background); }
    }
    .memory-changed {
      animation: memoryPulse 1s ease-in-out;
    }
    @media (max-width: 1200px) {
      #main-container {
        max-width: 100%;
      }
      #main-container.shifted-left {
        margin-left: 340px;
      }
      #main-container.shifted-right {
        margin-right: 340px;
      }
    }
    @media (max-width: 768px) {
      body {
        padding: 15px;
        gap: 15px;
      }
      #sidebar.open {
        width: 280px;
      }
      #memories-pane.open {
        width: 280px;
      }
      #main-container.shifted-left {
        margin-left: 310px;
      }
      #main-container.shifted-right {
        margin-right: 310px;
      }
      #controls {
        flex-wrap: wrap;
        gap: 15px;
        padding: 12px 15px;
      }
      #chat-container {
        max-height: calc(100vh - 240px);
      }
      #input-area {
        gap: 10px;
        padding: 12px 15px;
      }
      .message iframe {
        width: 100%;
        height: auto;
      }
    }
    @media (max-width: 480px) {
      body {
        padding: 0;
        flex-direction: column;
        gap: 0;
        height: 100vh;
        overflow: hidden;
      }
      #sidebar, #memories-pane {
        display: none;
        position: fixed;
        top: 0;
        width: 85%;
        height: 100vh;
        z-index: 30;
        transition: transform var(--transition-speed) ease;
        padding: 15px;
        border-radius: 0;
      }
      #sidebar {
        left: 0;
        transform: translateX(-100%);
      }
      #memories-pane {
        right: 0;
        transform: translateX(100%);
      }
      #sidebar.open {
        display: block;
        transform: translateX(0);
        width: 85%;
      }
      #memories-pane.open {
        display: block;
        transform: translateX(0);
        width: 85%;
      }
      #main-container {
        margin: 0;
        width: 100%;
        height: 100vh;
        max-width: none;
        padding: 0;
      }
      #controls {
        flex-direction: row;
        justify-content: space-between;
        align-items: center;
        padding: 10px;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 60px;
        z-index: 20;
        border-radius: 0;
        background-color: var(--secondary-color);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
      }
      #controls label {
        display: none;
      }
      #chat-container {
        margin-top: 60px;
        margin-bottom: 60px;
        height: calc(100vh - 120px);
        border: none;
        border-radius: 0;
        padding: 15px;
        box-shadow: none;
        overflow-y: auto;
      }
      #input-area {
        flex-direction: column;
        gap: 8px;
        padding: 10px;
        position: fixed;
        bottom: 0;
        left: 0;
        width: 100%;
        height: 60px;
        z-index: 20;
        border-radius: 0;
        background-color: var(--secondary-color);
        box-shadow: 0 -2px 8px rgba(0, 0, 0, 0.5);
        transition: height 0.3s ease;
      }
      #input-area.expanded {
        height: 200px;
      }
      #user-input {
        width: 100%;
        min-height: 40px;
        padding: 8px 12px;
        font-size: 14px;
        display: none;
      }
      #input-area.expanded #user-input {
        display: block;
      }
      #preview-area {
        max-width: 100%;
        justify-content: center;
        display: none;
      }
      #input-area.expanded #preview-area {
        display: flex;
      }
      #send-button {
        padding: 8px 16px;
        font-size: 12px;
        width: auto;
      }
      #file-input-label {
        padding: 8px 16px;
        font-size: 12px;
        width: auto;
        display: none;
      }
      #input-area.expanded #file-input-label {
        display: block;
      }
      #new-chat-button, #sidebar-toggle, #memories-toggle {
        padding: 8px 16px;
        font-size: 12px;
        width: auto;
      }
      .switch-container {
        display: none;
      }
      #input-area.expanded .switch-container {
        display: flex;
      }
      #controls .model-select-container {
        display: none;
      }
      .message iframe {
        width: 100%;
        height: auto;
        aspect-ratio: 16 / 9;
      }
    }
    #sidebar-toggle, #memories-toggle {
      position: relative;
      overflow: hidden;
    }
    #sidebar-toggle::after, #memories-toggle::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 100%;
      height: 100%;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 50%;
      transform: translate(-50%, -50%) scale(0);
      opacity: 0;
      transition: transform 0.5s, opacity 0.3s;
    }
    #sidebar-toggle:active::after, #memories-toggle:active::after {
      transform: translate(-50%, -50%) scale(2);
      opacity: 1;
      transition: 0s;
    }
  </style>
</head>
<body>
  <div id="sidebar"><h2 id="sidebar-label">History</h2></div>
  <div id="memories-pane"><h2 id="memories-label">Memories</h2></div>
  <div id="main-container">
    <div id="controls">
      <button id="sidebar-toggle">‚ò∞</button>
      <div class="model-select-container">
        <label for="model-select-button">Model:</label>
        <button class="model-select-button" id="model-select-button">Pro (Advanced)</button>
        <div class="model-select-dropdown" id="model-select-dropdown">
          <button data-value="openai-large">Pro (Advanced)</button>
          <button data-value="openai">Fast (Standard)</button>
        </div>
      </div>
      <button id="new-chat-button">New Chat</button>
      <button id="memories-toggle">üß†</button>
    </div>
    <div id="chat-container"></div>
    <div id="input-area">
      <label for="file-input" id="file-input-label">üìé Upload</label>
      <input type="file" id="file-input" accept="image/*, .txt, .pdf, .doc, .docx, .ppt, .pptx" multiple>
      <textarea id="user-input" placeholder="Type your message..."></textarea>
      <div id="preview-area"></div>
      <div class="switch-container">
        <label class="switch-label">Web Search</label>
        <label class="switch">
          <input type="checkbox" id="web-search-toggle">
          <span class="slider round"></span>
        </label>
      </div>
      <button id="send-button">Send ‚û§</button>
    </div>
  </div>

  <script>
    let conversation = [];
    let memories = JSON.parse(localStorage.getItem('memories')) || [];
    let sources = [];
    let chatHistory = JSON.parse(localStorage.getItem('chatHistory')) || [];
    let currentChatIndex = -1;
    const MAX_CHARS = 512000;
    let selectedModel = 'openai-large';
    let userLanguage = 'Unknown';
    let userCity = 'Unknown';
    let locationFetched = false;

    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.worker.min.js';

    function escapeHtml(text) {
      return text
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
    }

    function addMessageToChat(role, content, isNew = true) {
      const messageDiv = document.createElement('div');
      messageDiv.classList.add('message', role);
      
      const contentDiv = document.createElement('div');
      contentDiv.classList.add('message-content');

      if (typeof content === 'string') {
        const codeRegex = /```([\s\S]*?)```/g;
        let lastIndex = 0;
        let match;

        while ((match = codeRegex.exec(content)) !== null) {
          const preText = content.slice(lastIndex, match.index);
          if (preText) {
            const preLines = (role === 'user' ? escapeHtml(preText) : parseLatexAndMarkdown(preText)).split('<br>');
            preLines.forEach((line, index) => {
              const lineSpan = document.createElement('span');
              lineSpan.innerHTML = line;
              if (isNew) {
                lineSpan.style.opacity = '0';
                lineSpan.style.animation = `fadeIn 0.3s forwards`;
                lineSpan.style.animationDelay = `${index * 0.1}s`;
              } else {
                lineSpan.style.opacity = '1';
              }
              contentDiv.appendChild(lineSpan);
              if (index < preLines.length - 1) contentDiv.appendChild(document.createElement('br'));
            });
          }

          const codeCard = document.createElement('div');
          codeCard.classList.add('code-card');
          const codeContent = match[1].trim();
          const pre = document.createElement('pre');
          pre.textContent = codeContent;
          codeCard.appendChild(pre);

          const copyBtn = document.createElement('button');
          copyBtn.classList.add('copy-btn');
          copyBtn.textContent = 'Copy';
          copyBtn.addEventListener('click', () => {
            navigator.clipboard.writeText(codeContent).then(() => {
              copyBtn.textContent = 'Copied!';
              setTimeout(() => copyBtn.textContent = 'Copy', 2000);
            });
          });
          codeCard.appendChild(copyBtn);

          contentDiv.appendChild(codeCard);
          lastIndex = codeRegex.lastIndex;
        }

        const remainingText = content.slice(lastIndex);
        if (remainingText) {
          const lines = (role === 'user' ? escapeHtml(remainingText) : parseLatexAndMarkdown(remainingText)).split('<br>');
          lines.forEach((line, index) => {
            const lineSpan = document.createElement('span');
            lineSpan.innerHTML = line;
            if (isNew) {
              lineSpan.style.opacity = '0';
              lineSpan.style.animation = `fadeIn 0.3s forwards`;
              lineSpan.style.animationDelay = `${index * 0.1}s`;
            } else {
              lineSpan.style.opacity = '1';
            }
            contentDiv.appendChild(lineSpan);
            if (index < lines.length - 1) contentDiv.appendChild(document.createElement('br'));
          });
        }
      } else {
        content.forEach(item => {
          if (item.type === 'text') {
            const textSpan = document.createElement('span');
            textSpan.innerHTML = parseLatexAndMarkdown(item.text);
            if (isNew) {
              textSpan.style.opacity = '0';
              textSpan.style.animation = `fadeIn 0.3s forwards`;
            } else {
              textSpan.style.opacity = '1';
            }
            contentDiv.appendChild(textSpan);
          } else if (item.type === 'image_url') {
            const img = document.createElement('img');
            img.src = item.image_url.url;
            contentDiv.appendChild(img);
          }
        });
      }
      messageDiv.appendChild(contentDiv);
      document.getElementById('chat-container').appendChild(messageDiv);
      messageDiv.scrollIntoView({ behavior: 'smooth' });
      MathJax.Hub.Queue(["Typeset", MathJax.Hub, messageDiv]);
      return messageDiv;
    }

    function addErrorMessage(message) {
      const errorDiv = document.createElement('div');
      errorDiv.classList.add('error-message');
      errorDiv.innerHTML = `<span>${message}</span>`;
      document.getElementById('chat-container').appendChild(errorDiv);
      errorDiv.scrollIntoView({ behavior: 'smooth' });
      setTimeout(() => errorDiv.remove(), 5000);
    }

    function addThinkingMessage() {
      const messageDiv = document.createElement('div');
      messageDiv.classList.add('thinking');
      messageDiv.innerHTML = '<span>Thinking...</span>';
      document.getElementById('chat-container').appendChild(messageDiv);
      messageDiv.scrollIntoView({ behavior: 'smooth' });
      return messageDiv;
    }

    function addSearchLoadingMessage() {
      const messageDiv = document.createElement('div');
      messageDiv.classList.add('searching');
      messageDiv.innerHTML = '<span>Searching the web...</span>';
      document.getElementById('chat-container').appendChild(messageDiv);
      messageDiv.scrollIntoView({ behavior: 'smooth' });
      return messageDiv;
    }

    function removeLoadingMessage(loadingMessage) {
      if (loadingMessage) loadingMessage.remove();
    }

    function parseLatexAndMarkdown(text) {
      const sourceRegex = /\[(\d+)\]: \[([^\[\]]*?)\]\((https?:\/\/[^\s)]+?)\)/g;
      sources = [];
      let match;
      while ((match = sourceRegex.exec(text)) !== null) {
        sources[parseInt(match[1])] = { text: match[2], url: match[3] };
      }
      let latexText = text
        .replace(/\\\((.*?)\\\)/g, '$$$1$$')
        .replace(/\$(.*?)\$/g, (match, p1) => `$$${p1.replace(/\\(?![()])/g, '\\\\')}$$`);
      return latexText
        .replace(/^###### (.*)$/gim, '<h6>$1</h6>')
        .replace(/^##### (.*)$/gim, '<h5>$1</h5>')
        .replace(/^#### (.*)$/gim, '<h4>$1</h4>')
        .replace(/^### (.*)$/gim, '<h3>$1</h3>')
        .replace(/^## (.*)$/gim, '<h2>$1</h2>')
        .replace(/^# (.*)$/gim, '<h1>$1</h1>')
        .replace(/^---$/gim, '<hr>')
        .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
        .replace(/\*(.*?)\*/g, '<em>$1</em>')
        .replace(/~~(.*?)~~/g, '<del>$1</del>')
        .replace(/\[([^\[\]]*?)\]\((https?:\/\/[^\s)]+?)\)/g, '<a href="$2" target="_blank">$1</a>')
        .replace(/\[(\d+)\]/g, (match, number) => {
          const source = sources[parseInt(number)];
          return source && source.url.startsWith('http') ? `<sup><a href="${source.url}" target="_blank">${number}</a></sup>` : '';
        })
        .replace(/^- (.*)$/gim, '<li>$1</li>')
        .replace(/<\/li>\n<li>/g, '</li><li>')
        .replace(/(<li>.*<\/li>)/g, '<ul>$1</ul>')
        .replace(/\n{2,}/g, '<br>')
        .replace(/\n/g, '<br>');
    }

    function getRandomSeed() {
      return Math.floor(Math.random() * 1000000);
    }

    async function detectLanguage(text) {
      if (/[√§√∂√º√ü]/.test(text)) return 'de';
      if (/[√°√©√≠√≥√∫√±]/.test(text)) return 'es';
      if (/[√†√¢√ß√©√®√™√Æ√¥√ª√π]/.test(text)) return 'fr';
      return 'en';
    }

    async function getUserCity() {
      return new Promise((resolve) => {
        if (navigator.geolocation) {
          navigator.geolocation.getCurrentPosition(
            async (position) => {
              const { latitude, longitude } = position.coords;
              try {
                const response = await fetch(`https://nominatim.openstreetmap.org/reverse?lat=${latitude}&lon=${longitude}&format=json`);
                const data = await response.json();
                resolve(data.address.city || data.address.town || 'Unknown');
              } catch (error) {
                console.error('Geolocation fetch error:', error);
                resolve('Unknown');
              }
            },
            () => resolve('Unknown'),
            { timeout: 5000, maximumAge: 60000 }
          );
        } else {
          resolve('Unknown');
        }
      });
    }

    async function updateUserInfo() {
      if (!locationFetched) {
        const firstMessage = document.getElementById('user-input').value.trim() || conversation[0]?.content || ' ';
        userLanguage = await detectLanguage(firstMessage);
        userCity = await getUserCity();
        locationFetched = true;
      }
    }

    async function updateChatAndMemories() {
      const conversationText = conversation.slice(-5).map(m => typeof m.content === 'string' ? m.content : m.content[0]?.text || '').join('\n');
      const existingMemories = memories.map(m => m.content).join('\n');
      const language = await detectLanguage(conversationText);

      const requestBody = {
        messages: [
          {
            "role": "system",
            "content": `Perform two tasks based on the conversation:
1. Generate a concise chat name (1-3 words) summarizing the conversation, in ${language}.
2. Update the memories list with persistent, relevant facts: personal info (e.g., "Name: Alice"), plans (e.g., "Wants to go Paris on 15.03.2025"), personality (e.g., "Personality: cheerful"), AI response preferences (e.g., "Prefers short answers"), and interests (e.g., "Likes: coffee"). EXCLUDE temporary states (e.g., "Feeling: good") and chat-specific queries (e.g., "Wants to know what X is"). Add or edit based on explicit statements or light inference, but do not over-interpret. Only remove entries if they are explicitly contradicted or outdated; never delete all memories unless "forget everything" is in the conversation. If the input is large or unclear, preserve existing memories unchanged.
Return a JSON object with:
- "chatName": string (the chat name)
- "memories": array of strings (one memory per entry)

Conversation:
${conversationText}

Current Memories:
${existingMemories}`
          }
        ],
        model: 'openai',
        seed: getRandomSeed(),
        private: true,
        jsonMode: true
      };

      console.log('Chat & Memory AI Request Body:', JSON.stringify(requestBody));

      try {
        const response = await fetch('https://text.pollinations.ai/', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(requestBody)
        });

        if (!response.ok) {
          throw new Error(`Server responded with status ${response.status}`);
        }

        const result = await response.json();
        console.log('Chat & Memory AI Response:', result);

        if (!result.chatName || !Array.isArray(result.memories)) {
          throw new Error('Invalid response format');
        }

        const chatName = result.chatName.trim() || 'New Chat';
        const oldMemories = memories.map(m => m.content);
        const newMemories = result.memories;
        const memoriesChanged = oldMemories.length !== newMemories.length || oldMemories.some((m, i) => m !== newMemories[i]);

        memories = newMemories.map(content => ({ content, timestamp: new Date().toISOString() }));
        localStorage.setItem('memories', JSON.stringify(memories));
        
        if (memoriesChanged) {
          const memoriesPane = document.getElementById('memories-pane');
          memoriesPane.querySelectorAll('.memory-card').forEach(card => {
            card.classList.add('memory-changed');
            card.addEventListener('animationend', () => card.classList.remove('memory-changed'), { once: true });
          });
        }
        
        updateMemoriesPane();
        return chatName;
      } catch (error) {
        console.error('Chat & Memory update failed:', error);
        return 'New Chat';
      }
    }

    async function tryWebSearch(userText, maxAttempts = 3, isYouTube = false) {
      let attempts = 0;
      let searchResult = null;
      const currentDate = new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' });
      const language = await detectLanguage(userText);

      while (attempts < maxAttempts) {
        attempts++;
        const seed = getRandomSeed();
        try {
          let systemPrompt;
          if (isYouTube) {
            systemPrompt = `If you have no internet access, return exactly "XNoInternetX". Otherwise, search YouTube for ONE highly relevant, working, and embeddable video related to "${userText}". Prioritize videos from famous channels or with high view counts. Return the result in this exact format: {"youtube_url": "https://www.youtube.com/watch?v=VIDEO_ID", "title": "VIDEO_TITLE"}. If no suitable video is found, return {"youtube_url": null}.`;
          } else {
            systemPrompt = `If you have no internet access, return exactly "XNoInternetX". Otherwise, conduct a comprehensive and detailed web research for the given prompt in the language detected as "${language}". Provide current information (as of ${currentDate} or later, if available), including precise facts, background details, and relevant insights. Ensure each fact is accompanied by a source URL from trustworthy, up-to-date references. Return you answer in an array with two keys each: Fact and Source (the source must be the exact URL where the fact came from!). Make the search as detailed as possible and sum it up as short as possible without removing any details! Newer write anything without checking the sources for trust!`;
          }
          
          const searchResponse = await fetch('https://text.pollinations.ai/', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              messages: [
                {"role": "system", "content": systemPrompt},
                {"role": "user", "content": userText}
              ],
              model: 'searchgpt',
              seed: seed,
              jsonMode: true,
              private: true
            })
          });

          if (!searchResponse.ok) {
            console.log(`Attempt ${attempts}: API call failed with status ${searchResponse.status}`);
            if (attempts < maxAttempts) {
              await new Promise(resolve => setTimeout(resolve, 1000)); // Wait a bit longer between retries
              continue;
            } else {
              return { error: true, message: `Search failed after ${maxAttempts} attempts: API error ${searchResponse.status}`, attemptsMade: attempts };
            }
          }

          searchResult = await searchResponse[isYouTube ? 'json' : 'text']();

          // Check for "XNoInternetX" in the response
          if ((typeof searchResult === 'string' && searchResult.includes('XNoInternetX')) || 
              (typeof searchResult === 'object' && JSON.stringify(searchResult).includes('XNoInternetX')) ||
              (typeof searchResult === 'string' && searchResult.includes('"Fact":"XNoInternetX"'))) {
            console.log(`Attempt ${attempts}: No internet access detected`);
            if (attempts < maxAttempts) {
              await new Promise(resolve => setTimeout(resolve, 1000));
              continue;
            } else {
              return { error: true, message: `Search failed after ${maxAttempts} attempts: No internet access`, attemptsMade: attempts };
            }
          }

          // Check for error in the result
          if (searchResult && searchResult.error) {
            console.log(`Attempt ${attempts}: Search returned error: ${searchResult.message || 'undefined'}`);
            if (attempts < maxAttempts) {
              await new Promise(resolve => setTimeout(resolve, 1000));
              continue;
            } else {
              return { error: true, message: `Search failed after ${maxAttempts} attempts: ${searchResult.message || 'undefined'}`, attemptsMade: attempts };
            }
          }

          // For YouTube searches
          if (isYouTube) {
            if (searchResult && searchResult.youtube_url) {
              const videoIdMatch = searchResult.youtube_url.match(/v=([^&]+)/);
              if (videoIdMatch && videoIdMatch[1]) {
                try {
                  const response = await fetch(`https://www.youtube.com/oembed?url=${searchResult.youtube_url}`, { method: 'HEAD' });
                  if (response.ok) {
                    console.log(`YouTube Search Result (Attempt ${attempts}):`, searchResult);
                    return { error: false, result: searchResult, attemptsMade: attempts };
                  } else {
                    console.log(`Attempt ${attempts}: YouTube video validation failed`);
                    if (attempts < maxAttempts) {
                      await new Promise(resolve => setTimeout(resolve, 1000));
                      continue;
                    }
                  }
                } catch (e) {
                  console.log(`Attempt ${attempts}: YouTube validation error: ${e.message}`);
                  if (attempts < maxAttempts) {
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    continue;
                  }
                }
              } else {
                console.log(`Attempt ${attempts}: Invalid YouTube URL format`);
                if (attempts < maxAttempts) {
                  await new Promise(resolve => setTimeout(resolve, 1000));
                  continue;
                }
              }
            } else {
              console.log(`Attempt ${attempts}: No YouTube URL found in result`);
              if (attempts < maxAttempts) {
                await new Promise(resolve => setTimeout(resolve, 1000));
                continue;
              }
            }
            
            // If we reached here with YouTube search and all attempts failed, return error
            if (attempts >= maxAttempts) {
              return { error: true, message: `No valid YouTube video found after ${maxAttempts} attempts`, attemptsMade: attempts };
            }
          } else {
            // For regular web searches
            console.log(`Web Search Result (Attempt ${attempts}):`, searchResult);
            return { error: false, result: searchResult, attemptsMade: attempts };
          }
        } catch (error) {
          console.error(`Search attempt ${attempts} failed:`, error);
          if (attempts < maxAttempts) {
            await new Promise(resolve => setTimeout(resolve, 1000));
            continue;
          } else {
            return { error: true, message: `Search failed after ${maxAttempts} attempts: ${error.message}`, attemptsMade: attempts };
          }
        }
      }

      // Fallback return if loop exits without returning
      return { error: true, message: `Search failed after ${maxAttempts} attempts`, attemptsMade: attempts };
    }

    async function extractTextFromPDF(file) {
      try {
        const arrayBuffer = await file.arrayBuffer();
        const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
        let fullText = '';
        for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
          const page = await pdf.getPage(pageNum);
          const textContent = await page.getTextContent();
          const pageText = textContent.items.map(item => item.str).join(' ');
          fullText += `--- Page ${pageNum} ---\n${pageText}\n\n`;
        }
        return fullText || 'No text could be extracted from the PDF.';
      } catch (error) {
        return 'Error: Could not extract text from the PDF.';
      }
    }

    function readFileAsText(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = () => reject(reader.error);
        reader.readAsText(file);
      });
    }

    function readFileAsDataURL(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = () => reject(reader.error);
        reader.readAsDataURL(file);
      });
    }

    function updateChatHistory() {
      const sidebar = document.getElementById('sidebar');
      sidebar.innerHTML = '<h2 id="sidebar-label">History</h2>';
      const recentChats = chatHistory.slice(-15).reverse();
      recentChats.forEach((chat, index) => {
        const chatCard = document.createElement('div');
        chatCard.classList.add('chat-card');
        chatCard.innerHTML = `
          <p class="chat-name">${chat.name}</p>
          <button class="menu-btn">‚ãÆ</button>
          <div class="dropdown">
            <button class="delete-btn">Delete</button>
          </div>
        `;
        const menuBtn = chatCard.querySelector('.menu-btn');
        const dropdown = chatCard.querySelector('.dropdown');
        const deleteBtn = chatCard.querySelector('.delete-btn');

        chatCard.addEventListener('click', (e) => {
          if (e.target !== menuBtn && e.target !== deleteBtn) {
            loadChat(chat.messages, chatHistory.length - 1 - index);
          }
        });

        menuBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          const allDropdowns = document.querySelectorAll('.dropdown');
          allDropdowns.forEach(d => {
            if (d !== dropdown) d.style.display = 'none';
          });
          dropdown.style.display = dropdown.style.display === 'block' ? 'none' : 'block';
        });

        deleteBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          chatHistory.splice(chatHistory.length - 1 - index, 1);
          localStorage.setItem('chatHistory', JSON.stringify(chatHistory));
          updateChatHistory();
          if (currentChatIndex === chatHistory.length - index) {
            conversation = [];
            document.getElementById('chat-container').innerHTML = '';
            currentChatIndex = -1;
          }
        });

        document.addEventListener('click', (e) => {
          if (!chatCard.contains(e.target)) {
            dropdown.style.display = 'none';
          }
        });

        sidebar.appendChild(chatCard);
      });
    }

    function updateMemoriesPane() {
      const memoriesPane = document.getElementById('memories-pane');
      memoriesPane.innerHTML = '<h2 id="memories-label">Memories</h2>';
      const recentMemories = memories.slice(-15).reverse();
      recentMemories.forEach((memory, index) => {
        const memoryCard = document.createElement('div');
        memoryCard.classList.add('memory-card');
        memoryCard.innerHTML = `
          <p class="memory-text">${memory.content}</p>
          <button class="menu-btn">‚ãÆ</button>
          <div class="dropdown">
            <button class="delete-btn">Delete</button>
          </div>
        `;
        const menuBtn = memoryCard.querySelector('.menu-btn');
        const dropdown = memoryCard.querySelector('.dropdown');
        const deleteBtn = memoryCard.querySelector('.delete-btn');

        menuBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          const allDropdowns = document.querySelectorAll('.dropdown');
          allDropdowns.forEach(d => {
            if (d !== dropdown) d.style.display = 'none';
          });
          dropdown.style.display = dropdown.style.display === 'block' ? 'none' : 'block';
        });

        deleteBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          memories.splice(memories.length - 1 - index, 1);
          localStorage.setItem('memories', JSON.stringify(memories));
          updateMemoriesPane();
        });

        document.addEventListener('click', (e) => {
          if (!memoryCard.contains(e.target)) {
            dropdown.style.display = 'none';
          }
        });

        memoriesPane.appendChild(memoryCard);
      });
    }

    function loadChat(messages, index) {
      conversation = messages.slice();
      currentChatIndex = index;
      document.getElementById('chat-container').innerHTML = '';
      conversation.forEach(msg => addMessageToChat(msg.role, msg.content, false));
      document.getElementById('sidebar').classList.remove('open');
      document.getElementById('memories-pane').classList.remove('open');
      document.getElementById('main-container').classList.remove('shifted-left', 'shifted-right');
    }

    async function saveOrUpdateChat() {
      if (conversation.length) {
        const chatName = await updateChatAndMemories();
        if (currentChatIndex === -1) {
          chatHistory.push({ name: chatName, messages: conversation.slice(), files: [] });
          currentChatIndex = chatHistory.length - 1;
        } else {
          chatHistory[currentChatIndex] = { name: chatName, messages: conversation.slice(), files: [] };
        }
        localStorage.setItem('chatHistory', JSON.stringify(chatHistory));
        updateChatHistory();
      }
    }

    function calculateTextSize(messages) {
      let textContent = '';
      messages.forEach(msg => {
        if (typeof msg.content === 'string') {
          textContent += msg.content;
        } else if (Array.isArray(msg.content)) {
          msg.content.forEach(item => {
            if (item.type === 'text') {
              textContent += item.text;
            }
          });
        }
      });
      return textContent.length;
    }

    document.getElementById('sidebar-toggle').addEventListener('click', () => {
      const sidebar = document.getElementById('sidebar');
      const memoriesPane = document.getElementById('memories-pane');
      const mainContainer = document.getElementById('main-container');
      
      if (memoriesPane.classList.contains('open')) {
        memoriesPane.classList.remove('open');
        mainContainer.classList.remove('shifted-right');
      }
      
      sidebar.classList.toggle('open');
      if (sidebar.classList.contains('open')) {
        mainContainer.classList.add('shifted-left');
      } else {
        mainContainer.classList.remove('shifted-left');
      }
    });

    document.getElementById('memories-toggle').addEventListener('click', () => {
      const sidebar = document.getElementById('sidebar');
      const memoriesPane = document.getElementById('memories-pane');
      const mainContainer = document.getElementById('main-container');
      
      if (sidebar.classList.contains('open')) {
        sidebar.classList.remove('open');
        mainContainer.classList.remove('shifted-left');
      }
      
      memoriesPane.classList.toggle('open');
      if (memoriesPane.classList.contains('open')) {
        mainContainer.classList.add('shifted-right');
      } else {
        mainContainer.classList.remove('shifted-right');
      }
    });

    document.getElementById('file-input').addEventListener('change', (event) => {
      const files = Array.from(event.target.files);
      if (!files.length) return;

      const previewArea = document.getElementById('preview-area');
      previewArea.innerHTML = '';

      files.forEach(file => {
        const fileCard = document.createElement('div');
        fileCard.classList.add('file-card');
        fileCard.innerHTML = `<span>${file.name}</span>`;
        if (file.type.startsWith('image/')) {
          const reader = new FileReader();
          reader.onload = function(e) {
            const img = document.createElement('img');
            img.src = e.target.result;
            fileCard.appendChild(img);
          };
          reader.readAsDataURL(file);
        }
        previewArea.appendChild(fileCard);
      });
    });

    document.getElementById('send-button').addEventListener('click', async () => {
      const userText = document.getElementById('user-input').value.trim();
      const webSearchEnabled = document.getElementById('web-search-toggle').checked;
      const fileInput = document.getElementById('file-input');
      const files = fileInput.files ? Array.from(fileInput.files) : [];

      console.log('Send button clicked. Text:', userText, 'Files:', files.length);

      if (!userText && files.length === 0) {
        console.log('No text or files to send. Aborting.');
        return;
      }

      let totalTextChars = calculateTextSize(conversation);
      console.log('Initial text size:', totalTextChars);

      if (files.length > 0) {
        for (const file of files) {
          console.log('Processing file:', file.name);
          if (file.type.startsWith('image/')) {
            const dataUrl = await readFileAsDataURL(file);
            const imageMessage = {"role": "user", "content": [{"type": "image_url", "image_url": {"url": dataUrl}}]};
            addMessageToChat('user', imageMessage.content);
            conversation.push(imageMessage);
            console.log('Added image to conversation:', file.name);
          } else if (file.type === 'application/pdf') {
            const text = await extractTextFromPDF(file);
            totalTextChars += text.length;
            addMessageToChat('user', `Uploaded file: ${file.name}`);
            conversation.push({"role": "user", "content": `Uploaded file: ${file.name}\nContent:\n${text}`});
            console.log('Added PDF to conversation:', file.name);
          } else {
            const text = await readFileAsText(file);
            totalTextChars += text.length;
            addMessageToChat('user', `Uploaded file: ${file.name}`);
            conversation.push({"role": "user", "content": `Uploaded file: ${file.name}\nContent:\n${text}`});
            console.log('Added text file to conversation:', file.name);
          }
        }
      }

      if (userText) {
        const textMessage = {"role": "user", "content": userText};
        totalTextChars += userText.length;
        addMessageToChat('user', userText);
        conversation.push(textMessage);
        console.log('Added text to conversation:', userText);
      }

      if (totalTextChars > MAX_CHARS) {
        console.log('Text size exceeds limit:', totalTextChars);
        addErrorMessage('Oops! The conversation text exceeds the 512,000 character limit. Please start a new chat.');
        return;
      }

      console.log('Clearing input and preview area');
      document.getElementById('user-input').value = '';
      document.getElementById('preview-area').innerHTML = '';
      fileInput.value = '';
      const inputArea = document.getElementById('input-area');
      if (window.innerWidth <= 480) {
        inputArea.classList.remove('expanded');
      }

      let systemMessage = null;
      const currentDate = new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' });
      const isMathRequest = /\d\s*[\+\-\*\/]\s*\d|\b(math|calculate)\b/i.test(userText);
      const memoryContext = memories.map(m => m.content).join('\n');
      const memoryInstructions = `I can memorize key details you share across all chats (e.g., "Name: XX", "Wants to go XX on XX.XX.XXXX") and use them to assist you better. You can ask me to forget specific memories or all memories by saying "forget [specific detail]" or "forget everything". View or delete them manually via the Memories tab (üß†).`;

      if (webSearchEnabled || isMathRequest) {
        const searchLoadingMessage = isMathRequest ? addThinkingMessage() : addSearchLoadingMessage();
        
        console.log('Starting web search');
        let youtubeSearchResult = webSearchEnabled ? await tryWebSearch(userText, 3, true) : { error: true, attemptsMade: 0 };
        const webSearchResult = webSearchEnabled ? await tryWebSearch(userText, 3, false) : { error: true, attemptsMade: 0 };

        // If first YouTube search fails, try with a more generic query
        if (youtubeSearchResult.error || !youtubeSearchResult.result || !youtubeSearchResult.result.youtube_url) {
          console.log('First YouTube search failed, trying with a more generic query');
          youtubeSearchResult = webSearchEnabled ? await tryWebSearch(`tutorial about ${userText}`, 3, true) : { error: true, attemptsMade: 0 };
          
          // If that also fails, try one more time with an even more generic query
          if (youtubeSearchResult.error || !youtubeSearchResult.result || !youtubeSearchResult.result.youtube_url) {
            console.log('Second YouTube search failed, trying with an even more generic query');
            youtubeSearchResult = webSearchEnabled ? await tryWebSearch(`${userText} explained`, 3, true) : { error: true, attemptsMade: 0 };
          }
        }

        removeLoadingMessage(searchLoadingMessage);

        let combinedResults = '';
        let youtubeEmbed = '';
        
        // Process web search results
        if (!webSearchResult.error && webSearchResult.result) {
          combinedResults += `${webSearchResult.result}\n`;
        } else {
          console.log('Web search failed after all attempts');
          combinedResults += `Web search feature failed after ${webSearchResult.attemptsMade} attempts. `;
        }
        
        // Process YouTube results
        if (!youtubeSearchResult.error && youtubeSearchResult.result && youtubeSearchResult.result.youtube_url) {
          const videoIdMatch = youtubeSearchResult.result.youtube_url.match(/v=([^&]+)/);
          if (videoIdMatch && videoIdMatch[1]) {
            const videoId = videoIdMatch[1];
            youtubeEmbed = `<iframe width="560" height="315" src="https://www.youtube.com/embed/${videoId}?si=FhIchvTjZVmMrvti" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>`;
            combinedResults += `\n${youtubeEmbed}\nRelevant YouTube video: ${youtubeSearchResult.result.youtube_url} - ${youtubeSearchResult.result.title || ''}\n`;
          }
        } else {
          console.log('YouTube search failed after all attempts');
          combinedResults += `YouTube search feature failed after ${youtubeSearchResult.attemptsMade} attempts. `;
        }

        systemMessage = {
          "role": "system",
          "content": isMathRequest
            ? `${memoryInstructions}\nAnswer the user's math question in a single, concise line (e.g., "$$3 - 6 = -3$$") unless more explanation is explicitly requested. Use LaTeX notation (e.g., $$...$$) for all equations, ensuring proper rendering with no extra spacing or paragraphs around math. Verify each step and double-check the final result for accuracy. User language: ${userLanguage}, City: ${userCity}. Memories: ${memoryContext}. You can see, edit, delete, or add to these memories based on the conversation.`
            : `${memoryInstructions}\nYou have access to the following search results: ${combinedResults}. Use this information to answer the user's question with current details (as of ${currentDate} or later, if available). Mark nearly every fact with a compact source reference as "[Q[NUMBER]]" (e.g., "Tesla produced 10,000 Cybertrucks in 2025 Q2"). Number sources sequentially. Ensure the [Q[NUMBER]] in the text directly links to the corresponding URL in the sources list (example: [Q1](https://tesla.com/news)). For mathematical questions, answer in a single, concise line (e.g., "$$3 - 6 = -3$$") unless more explanation is requested. Use LaTeX notation (e.g., $$...$$) for equations with no extra spacing. Verify each step and double-check the final result for accuracy. User language: ${userLanguage}, City: ${userCity}. Memories: ${memoryContext}. You can see, edit, delete, or add to these memories based on the conversation.`
        };
      } else {
        systemMessage = {
          "role": "system",
          "content": `${memoryInstructions}\nAnswer the user's question. If needed use headings (###) and lists (-). If sources are available or relevant, mark facts with compact references as [Q[NUMBER]] (e.g., "[Q1]"). Ensure the [Number] in the text directly links to the corresponding URL (example: [Q1](https://tesla.com/news)). For mathematical questions, answer in a single, concise line (e.g., "$$3 - 6 = -3$$") unless more explanation is requested. Use LaTeX notation (e.g., $$...$$) for equations with no extra spacing. Verify each step and double-check the final result for accuracy. User language: ${userLanguage}, City: ${userCity}. Memories: ${memoryContext}. You can see, edit, delete, or add to these memories based on the conversation.`
        };
      }

      console.log('Sending AI request');
      const thinkingMessage = addThinkingMessage();
      try {
        const messages = systemMessage ? [systemMessage, ...conversation] : conversation;
        const response = await fetch('https://text.pollinations.ai/', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            messages: messages,
            model: selectedModel,
            seed: getRandomSeed(),
            private: true
          })
        });
        const data = await response.text();
        removeLoadingMessage(thinkingMessage);
        addMessageToChat('assistant', data);
        conversation.push({"role": "assistant", "content": data});
        await saveOrUpdateChat();
        console.log('AI response received and added:', data);

        if (userText.toLowerCase().includes('forget everything')) {
          memories = [];
          localStorage.setItem('memories', JSON.stringify(memories));
          updateMemoriesPane();
        } else if (userText.toLowerCase().includes('forget')) {
          const toForget = userText.toLowerCase().replace('forget', '').trim();
          memories = memories.filter(m => !m.content.toLowerCase().includes(toForget));
          localStorage.setItem('memories', JSON.stringify(memories));
          updateMemoriesPane();
        }
      } catch (error) {
        removeLoadingMessage(thinkingMessage);
        addMessageToChat('assistant', 'Sorry, an error occurred while retrieving the response.');
        console.error('AI request failed:', error);
      }
    });

    document.getElementById('user-input').addEventListener('keypress', (event) => {
      if (event.key === 'Enter' && !event.shiftKey) {
        event.preventDefault();
        document.getElementById('send-button').click();
      }
    });

    document.getElementById('new-chat-button').addEventListener('click', () => {
      conversation = [];
      document.getElementById('chat-container').innerHTML = '';
      document.getElementById('user-input').value = '';
      document.getElementById('preview-area').innerHTML = '';
      document.getElementById('file-input').value = '';
      sources = [];
      currentChatIndex = -1;
      document.getElementById('sidebar').classList.remove('open');
      document.getElementById('memories-pane').classList.remove('open');
      document.getElementById('main-container').classList.remove('shifted-left', 'shifted-right');
      const inputArea = document.getElementById('input-area');
      inputArea.classList.remove('expanded');
    });

    const modelSelectButton = document.getElementById('model-select-button');
    const modelSelectDropdown = document.getElementById('model-select-dropdown');
    modelSelectButton.addEventListener('click', () => {
      modelSelectDropdown.style.display = modelSelectDropdown.style.display === 'block' ? 'none' : 'block';
    });
    modelSelectDropdown.addEventListener('click', (event) => {
      if (event.target.tagName === 'BUTTON') {
        selectedModel = event.target.getAttribute('data-value');
        modelSelectButton.textContent = event.target.textContent;
        modelSelectDropdown.style.display = 'none';
      }
    });
    document.addEventListener('click', (event) => {
      if (!modelSelectButton.contains(event.target) && !modelSelectDropdown.contains(event.target)) {
        modelSelectDropdown.style.display = 'none';
      }
    });

    if (window.innerWidth <= 480) {
      const inputArea = document.getElementById('input-area');
      const sendButton = document.getElementById('send-button');
      sendButton.addEventListener('click', (e) => {
        if (!inputArea.classList.contains('expanded')) {
          e.preventDefault();
          inputArea.classList.add('expanded');
        }
      });
    }

    updateChatHistory();
    updateMemoriesPane();
    updateUserInfo();
  </script>
</body>
</html>
